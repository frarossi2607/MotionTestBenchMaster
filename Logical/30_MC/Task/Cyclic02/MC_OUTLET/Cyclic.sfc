PROGRAM _CYCLIC
(* @LANGUAGE := 'sfc' *)
INITIAL_STEP InitCPU:
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM InitCPU TO Init:=
CFG.DataOut.ConfigLoaded
END_TRANSITION
(* @SFCNOJUMP := 'Init' *)
STEP Init:
(* @LANGUAGE := 'st' *)
usiMasterRequest	:= GLOBAL_MASTER;
usiMasterStatus		:= UNKNOWN;

stOutletModule.iq_stStatus.q_xAlarmXCoreEnabled	:= FALSE;

IF VAR_AxOutletMain.nc_obj_inf.node_nr <> 0 THEN
	(* Outlet Master Axis *)
	stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_plrMasterPosition	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_prMasterVelocity	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_udiHomingPosition	:= ADR(stOutletModule.iq_stParameters.i_lrRephasingPosition);

	fbOutletMaster.i_xEnable							:= TRUE;
	fbOutletMaster.i_xToken								:= TRUE;
	fbOutletMaster.i_xVelocityControl					:= FALSE;
	fbOutletMaster.i_xThirdPartyMotor					:= FALSE;			
	fbOutletMaster.i_pAxisADR 							:= ADR(VAR_AxOutletModuleMaster);
	fbOutletMaster.i_pAxisMpLink						:= ADR(gOutletModuleMasterLink);
	fbOutletMaster.i_pstCmd								:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd);
	fbOutletMaster.i_pstParameter						:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam);
	fbOutletMaster.i_pstStatus							:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus);
	fbOutletMaster.i_pstAxisHome						:= ADR(VAR_OutletMasterHomeData);

	stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_xMachineMaster	:= FALSE;
	stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_udiMasterLink		:= ADR(gMasterLink);

	(* Main Axis Initialisation *)
	axAxisPresent[CST_MainAxis]	:= TRUE;

	stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_plrMasterPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_prMasterVelocity	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_udiHomingPosition	:= 0;

	uiNextHomingPositionIndex	:= CST_MainAxis;
	
	stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_rTorquePreload		:= CST_TorquePreLoad;
	stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_rTorqueErrorThreshold	:= CST_TorqueErrorThreshold;
	stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_rTorqueRamp			:= CST_TorqueRamp;
	stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_rMaxGearboxTorque		:= CFG_MC.MaximumGearBoxTorque.Outlet.Main;
	stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_rLagErrorThreshold	:= FC_mmToDegree(CFG_MC.Mechanical.MachineStep, CFG_MC.Mechanical.LagErrorThreshold);
	stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_xMachineMaster		:= FALSE;
	stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_udiMasterLink			:= ADR(gMasterLink);
	
	fbMain.i_xEnable					:= TRUE;
	fbMain.i_xToken						:= TRUE;
	fbMain.i_xThirdPartyMotor			:= CFG_MC.Axes.Outlet.Main.ThirdPartyMotor;
	fbMain.i_xVelocityControl			:= CFG_MC.Axes.Outlet.Main.VelocityControl;
	fbMain.i_xInductionMotorType		:= CFG_MC.Axes.Outlet.Main.InductionMotor;
	fbMain.i_strParTabName				:= 'OuMain';
	fbMain.i_pAxisADR 					:= ADR(VAR_AxOutletMain);
	fbMain.i_pAxisMpLink				:= ADR(gOutletMainLink);
	fbMain.i_pstCmd						:= ADR(stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stCmd);
	fbMain.i_pstParameter				:= ADR(stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam);
	fbMain.i_pstStatus					:= ADR(stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stStatus);
	fbMain.i_pstAxisHome				:= ADR(VAR_OutletMainHomeData);
		
	uiFirstOutletModuleAxis			:= CST_MainAxis;
	uiLastOutletModuleAxis			:= CST_MainAxis;
END_IF

(**********************************************************************************************************************************************************************************************************************)
IF VAR_AxOutletIn01.nc_obj_inf.node_nr <> 0 THEN
	axAxisPresent[CST_Inlet01] := TRUE;

	(* Inlet01 Initialisation *)
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_plrMasterPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_prMasterVelocity	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_udiHomingPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	
	uiNextHomingPositionIndex := CST_Inlet01;
	
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_rTorquePreload			:= CST_TorquePreLoad;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_rTorqueErrorThreshold	:= CST_TorqueErrorThreshold;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_rTorqueRamp			:= CST_TorqueRamp;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_rMaxGearboxTorque		:= CFG_MC.MaximumGearBoxTorque.Outlet.In[1];
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_rLagErrorThreshold		:= FC_mmToDegree(CFG_MC.Mechanical.MachineStep, CFG_MC.Mechanical.LagErrorThreshold);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_xMachineMaster			:= FALSE;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_udiMasterLink			:= ADR(gMasterLink);
	
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_stInductionMotorConfig.RatedVoltage			:= CFG_MC.Axes.Outlet.In[1].InductionMotorData.RatedVoltage;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_stInductionMotorConfig.RatedCurrent			:= CFG_MC.Axes.Outlet.In[1].InductionMotorData.RatedCurrent;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_stInductionMotorConfig.RatedSpeed				:= CFG_MC.Axes.Outlet.In[1].InductionMotorData.RatedSpeed;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_stInductionMotorConfig.RatedFrequency			:= CFG_MC.Axes.Outlet.In[1].InductionMotorData.RatedFrequency;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_stInductionMotorConfig.PowerFactor				:= CFG_MC.Axes.Outlet.In[1].InductionMotorData.PowerFactor;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_stInductionMotorConfig.ThermalTrippingTime		:= CFG_MC.Axes.Outlet.In[1].InductionMotorData.ThermalTrippingTime;
	
	fbInlet01.i_xEnable					:= TRUE;
	fbInlet01.i_xToken					:= TRUE;
	fbInlet01.i_xThirdPartyMotor		:= CFG_MC.Axes.Outlet.In[1].ThirdPartyMotor;	
	fbInlet01.i_xVelocityControl		:= CFG_MC.Axes.Outlet.In[1].VelocityControl;
	fbInlet01.i_xInductionMotorType		:= CFG_MC.Axes.Outlet.In[1].InductionMotor;
	fbInlet01.i_strParTabName			:= 'OuIn01';
	fbInlet01.i_pAxisADR 				:= ADR(VAR_AxOutletIn01);
	fbInlet01.i_pAxisMpLink				:= ADR(gOutInlet01Link);
	fbInlet01.i_pstCmd					:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stCmd);
	fbInlet01.i_pstParameter			:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam);
	fbInlet01.i_pstStatus				:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stStatus);
	fbInlet01.i_pstAxisHome				:= ADR(VAR_OutletIn01HomeData);
	
	IF CFG_MC.Axes.Outlet.In[1].VelocityControl THEN
		stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_plrMasterPosition	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
		stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stParam.i_prMasterVelocity	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	END_IF
	uiFirstOutletModuleAxis		:= CST_Inlet01;
END_IF

IF VAR_AxOutletIn02.nc_obj_inf.node_nr <> 0 THEN
	axAxisPresent[CST_Inlet02] := TRUE;
	
	(* Inlet02 Initialisation *)
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_plrMasterPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_prMasterVelocity	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_udiHomingPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[uiNextHomingPositionIndex].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	
	uiNextHomingPositionIndex := CST_Inlet02;
	
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_rTorquePreload			:= CST_TorquePreLoad;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_rTorqueErrorThreshold	:= CST_TorqueErrorThreshold;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_rTorqueRamp			:= CST_TorqueRamp;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_rMaxGearboxTorque		:= CFG_MC.MaximumGearBoxTorque.Outlet.In[2];
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_rLagErrorThreshold		:= FC_mmToDegree(CFG_MC.Mechanical.MachineStep, CFG_MC.Mechanical.LagErrorThreshold);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_xMachineMaster			:= FALSE;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_udiMasterLink			:= ADR(gMasterLink);
	
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_stInductionMotorConfig.RatedVoltage			:= CFG_MC.Axes.Outlet.In[2].InductionMotorData.RatedVoltage;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_stInductionMotorConfig.RatedCurrent			:= CFG_MC.Axes.Outlet.In[2].InductionMotorData.RatedCurrent;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_stInductionMotorConfig.RatedSpeed				:= CFG_MC.Axes.Outlet.In[2].InductionMotorData.RatedSpeed;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_stInductionMotorConfig.RatedFrequency			:= CFG_MC.Axes.Outlet.In[2].InductionMotorData.RatedFrequency;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_stInductionMotorConfig.PowerFactor				:= CFG_MC.Axes.Outlet.In[2].InductionMotorData.PowerFactor;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_stInductionMotorConfig.ThermalTrippingTime		:= CFG_MC.Axes.Outlet.In[2].InductionMotorData.ThermalTrippingTime;

	fbInlet02.i_xEnable					:= TRUE;
	fbInlet02.i_xToken					:= TRUE;
	fbInlet02.i_xThirdPartyMotor		:= CFG_MC.Axes.Outlet.In[2].ThirdPartyMotor;
	fbInlet02.i_xVelocityControl		:= CFG_MC.Axes.Outlet.In[2].VelocityControl;
	fbInlet02.i_xInductionMotorType		:= CFG_MC.Axes.Outlet.In[2].InductionMotor;
	fbInlet02.i_strParTabName			:= 'OuIn02';
	fbInlet02.i_pAxisADR 				:= ADR(VAR_AxOutletIn02);
	fbInlet02.i_pAxisMpLink				:= ADR(gOutInlet02Link);
	fbInlet02.i_pstCmd					:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stCmd);
	fbInlet02.i_pstParameter			:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam);
	fbInlet02.i_pstStatus				:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stStatus);
	fbInlet02.i_pstAxisHome				:= ADR(VAR_OutletIn02HomeData);

	IF CFG_MC.Axes.Outlet.In[2].VelocityControl THEN
		stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_plrMasterPosition	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
		stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stParam.i_prMasterVelocity	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	END_IF
	uiFirstOutletModuleAxis		:= CST_Inlet02;
END_IF

IF VAR_AxOutletIn03.nc_obj_inf.node_nr <> 0 THEN
	axAxisPresent[CST_Inlet03] := TRUE;
	
	(* Inlet03 Initialisation *)
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_plrMasterPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_prMasterVelocity	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_udiHomingPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[uiNextHomingPositionIndex].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	
	uiNextHomingPositionIndex := CST_Inlet03;
	
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_rTorquePreload			:= CST_TorquePreLoad;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_rTorqueErrorThreshold	:= CST_TorqueErrorThreshold;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_rTorqueRamp			:= CST_TorqueRamp;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_rMaxGearboxTorque		:= CFG_MC.MaximumGearBoxTorque.Outlet.In[3];
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_rLagErrorThreshold		:= FC_mmToDegree(CFG_MC.Mechanical.MachineStep, CFG_MC.Mechanical.LagErrorThreshold);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_xMachineMaster			:= FALSE;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_udiMasterLink			:= ADR(gMasterLink);
	
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_stInductionMotorConfig.RatedVoltage			:= CFG_MC.Axes.Outlet.In[3].InductionMotorData.RatedVoltage;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_stInductionMotorConfig.RatedCurrent			:= CFG_MC.Axes.Outlet.In[3].InductionMotorData.RatedCurrent;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_stInductionMotorConfig.RatedSpeed				:= CFG_MC.Axes.Outlet.In[3].InductionMotorData.RatedSpeed;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_stInductionMotorConfig.RatedFrequency			:= CFG_MC.Axes.Outlet.In[3].InductionMotorData.RatedFrequency;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_stInductionMotorConfig.PowerFactor				:= CFG_MC.Axes.Outlet.In[3].InductionMotorData.PowerFactor;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_stInductionMotorConfig.ThermalTrippingTime		:= CFG_MC.Axes.Outlet.In[3].InductionMotorData.ThermalTrippingTime;
	
	fbInlet03.i_xEnable					:= TRUE;
	fbInlet03.i_xToken					:= TRUE;
	fbInlet03.i_xThirdPartyMotor		:= CFG_MC.Axes.Outlet.In[3].ThirdPartyMotor;
	fbInlet03.i_xVelocityControl		:= CFG_MC.Axes.Outlet.In[3].VelocityControl;
	fbInlet03.i_xInductionMotorType		:= CFG_MC.Axes.Outlet.In[3].InductionMotor;
	fbInlet03.i_strParTabName			:= 'OuIn03';
	fbInlet03.i_pAxisADR 				:= ADR(VAR_AxOutletIn03);
	fbInlet03.i_pAxisMpLink				:= ADR(gOutInlet03Link);
	fbInlet03.i_pstCmd					:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stCmd);
	fbInlet03.i_pstParameter			:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam);
	fbInlet03.i_pstStatus				:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stStatus);
	fbInlet03.i_pstAxisHome				:= ADR(VAR_OutletIn03HomeData);
	
	IF CFG_MC.Axes.Outlet.In[3].VelocityControl THEN
		stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_plrMasterPosition	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
		stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stParam.i_prMasterVelocity	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	END_IF
	uiFirstOutletModuleAxis		:= CST_Inlet03;
END_IF

IF VAR_AxOutletIn04.nc_obj_inf.node_nr <> 0 THEN
	axAxisPresent[CST_Inlet04] := TRUE;
	
	(* Inlet04 Initialisation *)
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_plrMasterPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_prMasterVelocity	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_udiHomingPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[uiNextHomingPositionIndex].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	
	uiNextHomingPositionIndex := CST_Inlet04;
	
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_rTorquePreload			:= CST_TorquePreLoad;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_rTorqueErrorThreshold	:= CST_TorqueErrorThreshold;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_rTorqueRamp			:= CST_TorqueRamp;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_rMaxGearboxTorque		:= CFG_MC.MaximumGearBoxTorque.Outlet.In[4];
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_rLagErrorThreshold		:= FC_mmToDegree(CFG_MC.Mechanical.MachineStep, CFG_MC.Mechanical.LagErrorThreshold);
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_xMachineMaster			:= FALSE;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_udiMasterLink			:= ADR(gMasterLink);
	
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_stInductionMotorConfig.RatedVoltage			:= CFG_MC.Axes.Outlet.In[4].InductionMotorData.RatedVoltage;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_stInductionMotorConfig.RatedCurrent			:= CFG_MC.Axes.Outlet.In[4].InductionMotorData.RatedCurrent;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_stInductionMotorConfig.RatedSpeed				:= CFG_MC.Axes.Outlet.In[4].InductionMotorData.RatedSpeed;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_stInductionMotorConfig.RatedFrequency			:= CFG_MC.Axes.Outlet.In[4].InductionMotorData.RatedFrequency;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_stInductionMotorConfig.PowerFactor				:= CFG_MC.Axes.Outlet.In[4].InductionMotorData.PowerFactor;
	stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_stInductionMotorConfig.ThermalTrippingTime		:= CFG_MC.Axes.Outlet.In[4].InductionMotorData.ThermalTrippingTime;

	fbInlet04.i_xEnable					:= TRUE;
	fbInlet04.i_xToken					:= TRUE;
	fbInlet04.i_xThirdPartyMotor		:= CFG_MC.Axes.Outlet.In[4].ThirdPartyMotor;
	fbInlet04.i_xVelocityControl		:= CFG_MC.Axes.Outlet.In[4].VelocityControl;
	fbInlet04.i_xInductionMotorType		:= CFG_MC.Axes.Outlet.In[4].InductionMotor;
	fbInlet04.i_strParTabName			:= 'OuIn04';
	fbInlet04.i_pAxisADR 				:= ADR(VAR_AxOutletIn04);
	fbInlet04.i_pAxisMpLink				:= ADR(gOutInlet04Link);
	fbInlet04.i_pstCmd					:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stCmd);
	fbInlet04.i_pstParameter			:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam);
	fbInlet04.i_pstStatus				:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stStatus);
	fbInlet04.i_pstAxisHome				:= ADR(VAR_OutletIn04HomeData);
	
	IF CFG_MC.Axes.Outlet.In[4].VelocityControl THEN
		stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_plrMasterPosition	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
		stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stParam.i_prMasterVelocity	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	END_IF
	uiFirstOutletModuleAxis		:= CST_Inlet04;
END_IF

(****************************************************************************************************************************************************************************************************************)
IF VAR_AxOutletOut01.nc_obj_inf.node_nr <> 0 THEN
	axAxisPresent[CST_Outlet01] := TRUE;
	
	(* Outlet01 Initialisation *)
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_plrMasterPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_prMasterVelocity	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_udiHomingPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	
	uiNextHomingPositionIndex := CST_Outlet01;
	
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_rTorquePreload		:= CST_TorquePreLoad;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_rTorqueErrorThreshold	:= CST_TorqueErrorThreshold;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_rTorqueRamp			:= CST_TorqueRamp;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_rMaxGearboxTorque		:= CFG_MC.MaximumGearBoxTorque.Outlet.Out[1];
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_rLagErrorThreshold	:= FC_mmToDegree(CFG_MC.Mechanical.MachineStep, CFG_MC.Mechanical.LagErrorThreshold);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_xMachineMaster		:= FALSE;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_udiMasterLink			:= ADR(gMasterLink);
	
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_stInductionMotorConfig.RatedVoltage			:= CFG_MC.Axes.Outlet.Out[1].InductionMotorData.RatedVoltage;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_stInductionMotorConfig.RatedCurrent			:= CFG_MC.Axes.Outlet.Out[1].InductionMotorData.RatedCurrent;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_stInductionMotorConfig.RatedSpeed				:= CFG_MC.Axes.Outlet.Out[1].InductionMotorData.RatedSpeed;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_stInductionMotorConfig.RatedFrequency			:= CFG_MC.Axes.Outlet.Out[1].InductionMotorData.RatedFrequency;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_stInductionMotorConfig.PowerFactor			:= CFG_MC.Axes.Outlet.Out[1].InductionMotorData.PowerFactor;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_stInductionMotorConfig.ThermalTrippingTime	:= CFG_MC.Axes.Outlet.Out[1].InductionMotorData.ThermalTrippingTime;
	
	fbOutlet01.i_xEnable				:= TRUE;
	fbOutlet01.i_xToken					:= TRUE;
	fbOutlet01.i_xThirdPartyMotor		:= CFG_MC.Axes.Outlet.Out[1].ThirdPartyMotor;
	fbOutlet01.i_xVelocityControl		:= CFG_MC.Axes.Outlet.Out[1].VelocityControl;
	fbOutlet01.i_xInductionMotorType	:= CFG_MC.Axes.Outlet.Out[1].InductionMotor;
	fbOutlet01.i_strParTabName			:= 'OuOu01';
	fbOutlet01.i_pAxisADR 				:= ADR(VAR_AxOutletOut01);;
	fbOutlet01.i_pAxisMpLink			:= ADR(gOutOutlet01Link);
	fbOutlet01.i_pstCmd					:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stCmd);
	fbOutlet01.i_pstParameter			:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam);
	fbOutlet01.i_pstStatus				:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stStatus);
	fbOutlet01.i_pstAxisHome			:= ADR(VAR_OutletOut01HomeData);
	
	IF CFG_MC.Axes.Outlet.Out[1].VelocityControl THEN
		stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_plrMasterPosition	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
		stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stParam.i_prMasterVelocity	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	END_IF
	uiLastOutletModuleAxis		:= CST_Outlet01;
ELSE
	uiNextHomingPositionIndex	:= CST_MainAxis;
END_IF

IF VAR_AxOutletOut02.nc_obj_inf.node_nr <> 0 THEN
	axAxisPresent[CST_Outlet02] := TRUE;
	
	(* Outlet02 Initialisation *)
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_plrMasterPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_prMasterVelocity	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_udiHomingPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[uiNextHomingPositionIndex].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	
	uiNextHomingPositionIndex := CST_Outlet02;
	
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_rTorquePreload		:= CST_TorquePreLoad;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_rTorqueErrorThreshold	:= CST_TorqueErrorThreshold;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_rTorqueRamp			:= CST_TorqueRamp;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_rMaxGearboxTorque		:= CFG_MC.MaximumGearBoxTorque.Outlet.Out[2];
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_rLagErrorThreshold	:= FC_mmToDegree(CFG_MC.Mechanical.MachineStep, CFG_MC.Mechanical.LagErrorThreshold);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_xMachineMaster		:= FALSE;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_udiMasterLink			:= ADR(gMasterLink);
	
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_stInductionMotorConfig.RatedVoltage			:= CFG_MC.Axes.Outlet.Out[2].InductionMotorData.RatedVoltage;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_stInductionMotorConfig.RatedCurrent			:= CFG_MC.Axes.Outlet.Out[2].InductionMotorData.RatedCurrent;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_stInductionMotorConfig.RatedSpeed				:= CFG_MC.Axes.Outlet.Out[2].InductionMotorData.RatedSpeed;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_stInductionMotorConfig.RatedFrequency			:= CFG_MC.Axes.Outlet.Out[2].InductionMotorData.RatedFrequency;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_stInductionMotorConfig.PowerFactor			:= CFG_MC.Axes.Outlet.Out[2].InductionMotorData.PowerFactor;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_stInductionMotorConfig.ThermalTrippingTime	:= CFG_MC.Axes.Outlet.Out[2].InductionMotorData.ThermalTrippingTime;
	
	fbOutlet02.i_xEnable				:= TRUE;
	fbOutlet02.i_xToken					:= TRUE;
	fbOutlet02.i_xThirdPartyMotor		:= CFG_MC.Axes.Outlet.Out[2].ThirdPartyMotor;
	fbOutlet02.i_xVelocityControl		:= CFG_MC.Axes.Outlet.Out[2].VelocityControl;
	fbOutlet02.i_xInductionMotorType	:= CFG_MC.Axes.Outlet.Out[2].InductionMotor;
	fbOutlet02.i_strParTabName			:= 'OuOu02';
	fbOutlet02.i_pAxisADR 				:= ADR(VAR_AxOutletOut02);
	fbOutlet02.i_pAxisMpLink			:= ADR(gOutOutlet02Link);
	fbOutlet02.i_pstCmd					:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stCmd);
	fbOutlet02.i_pstParameter			:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam);
	fbOutlet02.i_pstStatus				:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stStatus);
	fbOutlet02.i_pstAxisHome			:= ADR(VAR_OutletOut02HomeData);
	
	IF CFG_MC.Axes.Outlet.Out[2].VelocityControl THEN
		stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_plrMasterPosition	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
		stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stParam.i_prMasterVelocity	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	END_IF
	uiLastOutletModuleAxis		:= CST_Outlet02;
END_IF

IF VAR_AxOutletOut03.nc_obj_inf.node_nr <> 0 THEN
	axAxisPresent[CST_Outlet03] := TRUE;
	
	(* Outlet03 Initialisation *)
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_plrMasterPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_prMasterVelocity	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_udiHomingPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[uiNextHomingPositionIndex].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	
	uiNextHomingPositionIndex := CST_Outlet03;
	
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_rTorquePreload		:= CST_TorquePreLoad;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_rTorqueErrorThreshold	:= CST_TorqueErrorThreshold;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_rTorqueRamp			:= CST_TorqueRamp;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_rMaxGearboxTorque		:= CFG_MC.MaximumGearBoxTorque.Outlet.Out[3];
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_rLagErrorThreshold	:= FC_mmToDegree(CFG_MC.Mechanical.MachineStep, CFG_MC.Mechanical.LagErrorThreshold);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_xMachineMaster		:= FALSE;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_udiMasterLink			:= ADR(gMasterLink);
	
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_stInductionMotorConfig.RatedVoltage			:= CFG_MC.Axes.Outlet.Out[3].InductionMotorData.RatedVoltage;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_stInductionMotorConfig.RatedCurrent			:= CFG_MC.Axes.Outlet.Out[3].InductionMotorData.RatedCurrent;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_stInductionMotorConfig.RatedSpeed				:= CFG_MC.Axes.Outlet.Out[3].InductionMotorData.RatedSpeed;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_stInductionMotorConfig.RatedFrequency			:= CFG_MC.Axes.Outlet.Out[3].InductionMotorData.RatedFrequency;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_stInductionMotorConfig.PowerFactor			:= CFG_MC.Axes.Outlet.Out[3].InductionMotorData.PowerFactor;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_stInductionMotorConfig.ThermalTrippingTime	:= CFG_MC.Axes.Outlet.Out[3].InductionMotorData.ThermalTrippingTime;
	
	fbOutlet03.i_xEnable				:= TRUE;
	fbOutlet03.i_xToken					:= TRUE;
	fbOutlet03.i_xThirdPartyMotor		:= CFG_MC.Axes.Outlet.Out[3].ThirdPartyMotor;
	fbOutlet03.i_xVelocityControl		:= CFG_MC.Axes.Outlet.Out[3].VelocityControl;
	fbOutlet03.i_xInductionMotorType	:= CFG_MC.Axes.Outlet.Out[3].InductionMotor;
	fbOutlet03.i_strParTabName			:= 'OuOu03';
	fbOutlet03.i_pAxisADR 				:= ADR(VAR_AxOutletOut03);
	fbOutlet03.i_pAxisMpLink			:= ADR(gOutOutlet03Link);
	fbOutlet03.i_pstCmd					:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stCmd);
	fbOutlet03.i_pstParameter			:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam);
	fbOutlet03.i_pstStatus				:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stStatus);
	fbOutlet03.i_pstAxisHome			:= ADR(VAR_OutletOut03HomeData);
	
	IF CFG_MC.Axes.Outlet.Out[3].VelocityControl THEN
		stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_plrMasterPosition	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
		stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stParam.i_prMasterVelocity	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	END_IF
	uiLastOutletModuleAxis		:= CST_Outlet03;
END_IF

IF VAR_AxOutletOut04.nc_obj_inf.node_nr <> 0 THEN
	axAxisPresent[CST_Outlet04] := TRUE;
	
	(* Outlet04 Initialisation *)
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_plrMasterPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_prMasterVelocity	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_udiHomingPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[uiNextHomingPositionIndex].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
	
	uiNextHomingPositionIndex := CST_Outlet04;
	
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_rTorquePreload		:= CST_TorquePreLoad;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_rTorqueErrorThreshold	:= CST_TorqueErrorThreshold;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_rTorqueRamp			:= CST_TorqueRamp;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_rMaxGearboxTorque		:= CFG_MC.MaximumGearBoxTorque.Outlet.Out[4];
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_rLagErrorThreshold	:= FC_mmToDegree(CFG_MC.Mechanical.MachineStep, CFG_MC.Mechanical.LagErrorThreshold);
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_xMachineMaster		:= FALSE;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_udiMasterLink			:= ADR(gMasterLink);
	
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_stInductionMotorConfig.RatedVoltage			:= CFG_MC.Axes.Outlet.Out[4].InductionMotorData.RatedVoltage;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_stInductionMotorConfig.RatedCurrent			:= CFG_MC.Axes.Outlet.Out[4].InductionMotorData.RatedCurrent;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_stInductionMotorConfig.RatedSpeed				:= CFG_MC.Axes.Outlet.Out[4].InductionMotorData.RatedSpeed;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_stInductionMotorConfig.RatedFrequency			:= CFG_MC.Axes.Outlet.Out[4].InductionMotorData.RatedFrequency;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_stInductionMotorConfig.PowerFactor			:= CFG_MC.Axes.Outlet.Out[4].InductionMotorData.PowerFactor;
	stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_stInductionMotorConfig.ThermalTrippingTime	:= CFG_MC.Axes.Outlet.Out[4].InductionMotorData.ThermalTrippingTime;
	
	fbOutlet04.i_xEnable				:= TRUE;
	fbOutlet04.i_xToken					:= TRUE;
	fbOutlet04.i_xThirdPartyMotor		:= CFG_MC.Axes.Outlet.Out[4].ThirdPartyMotor;
	fbOutlet04.i_xVelocityControl		:= CFG_MC.Axes.Outlet.Out[4].VelocityControl;
	fbOutlet04.i_xInductionMotorType	:= CFG_MC.Axes.Outlet.Out[4].InductionMotor;
	fbOutlet04.i_strParTabName			:= 'OuOu04';
	fbOutlet04.i_pAxisADR 				:= ADR(VAR_AxOutletOut04);
	fbOutlet04.i_pAxisMpLink			:= ADR(gOutOutlet04Link);
	fbOutlet04.i_pstCmd					:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stCmd);
	fbOutlet04.i_pstParameter			:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam);
	fbOutlet04.i_pstStatus				:= ADR(stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stStatus);
	fbOutlet04.i_pstAxisHome			:= ADR(VAR_OutletOut04HomeData);
	
	IF CFG_MC.Axes.Outlet.Out[4].VelocityControl THEN
		stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_plrMasterPosition	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
		stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stParam.i_prMasterVelocity	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
	END_IF
	uiLastOutletModuleAxis		:= CST_Outlet04;
END_IF

uiAxisToken := CST_MainAxis;

stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_rEndlessJerk				:= CFG_MC.Movements.Jerk;
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_rEmergencyDeceleration	:= VAR_EmergencyDec;
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_rShutdownDeceleration		:= VAR_ShutDownDec;
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_rJogDeceleration			:= CST_JogDeceleration;

FOR uiAxisIndex := CST_FirstOutletModuleAxis TO CST_LastOutletModuleAxis BY 1 DO
	stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stParam.i_rEndlessJerk			:= CFG_MC.Movements.Jerk;
	stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stParam.i_rEmergencyDeceleration	:= VAR_EmergencyDec;
	stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stParam.i_rShutdownDeceleration	:= VAR_ShutDownDec;
	stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stParam.i_rJogDeceleration		:= CST_JogDeceleration;
END_FOR


//Outlet Axes - HMI Presence
FOR axPresentIndex := 11 TO 19 DO
	IF axAxisPresent[axPresentIndex] THEN
		HMI_MC_AxisPresent._300 := TRUE;
		CASE axPresentIndex OF
			11:HMI_MC_AxisPresent._311 := TRUE;
			12:HMI_MC_AxisPresent._312 := TRUE;
			13:HMI_MC_AxisPresent._313 := TRUE;
			14:HMI_MC_AxisPresent._314 := TRUE;
			15:HMI_MC_AxisPresent._315 := TRUE;
			16:HMI_MC_AxisPresent._316 := TRUE;
			17:HMI_MC_AxisPresent._317 := TRUE;
			18:HMI_MC_AxisPresent._318 := TRUE;
			19:HMI_MC_AxisPresent._319 := TRUE;
		END_CASE
	END_IF
END_FOR
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Init TO InitModule:=
TRUE
END_TRANSITION
(* @SFCNOJUMP := 'InitModule' *)
STEP InitModule:
(* @LANGUAGE := 'st' *)

(* Exception Init *)
(* FBs errors alarm *)
fbQuickStopFromPlc.i_psAlarmName			:= ADR('PlcQuickStop');
fbQuickStopFromPlc.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
fbQuickStopFromPlc.i_pxAcknowledge			:= ADR(stOutletModule.iq_stCmd.i_xReset);
fbQuickStopFromPlc.i_pxInitCoreDone			:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
fbQuickStopFromPlc.i_xAutoAck				:= TRUE;

fbMasterError.i_psAlarmName					:= ADR('MasterAxisError');
fbMasterError.i_pstMpAlarmXLink				:= ADR(gOutletAlarmXCoreLink);
fbMasterError.i_pxAcknowledge				:= ADR(stOutletModule.iq_stCmd.i_xReset);
fbMasterError.i_pxInitCoreDone				:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
fbMasterError.i_xAutoAck					:= FALSE;

fbMainAxisError.i_psAlarmName				:= ADR('OutletMainAxisError');
fbMainAxisError.i_pstMpAlarmXLink			:= ADR(gOutletAlarmXCoreLink);
fbMainAxisError.i_pxAcknowledge				:= ADR(stOutletModule.iq_stCmd.i_xReset);
fbMainAxisError.i_pxInitCoreDone			:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
fbMainAxisError.i_xAutoAck					:= FALSE;

IF axAxisPresent[CST_Inlet01] THEN
	fbInlet01Error.i_psAlarmName			:= ADR('OutInlet01AxisError');
	fbInlet01Error.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbInlet01Error.i_pxAcknowledge			:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbInlet01Error.i_pxInitCoreDone			:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbInlet01Error.i_xAutoAck				:= FALSE;
END_IF

IF axAxisPresent[CST_Inlet02] THEN
	fbInlet02Error.i_psAlarmName			:= ADR('OutInlet02AxisError');
	fbInlet02Error.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbInlet02Error.i_pxAcknowledge			:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbInlet02Error.i_pxInitCoreDone			:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbInlet02Error.i_xAutoAck				:= FALSE;
END_IF

IF axAxisPresent[CST_Inlet03] THEN
	fbInlet03Error.i_psAlarmName			:= ADR('OutInlet03AxisError');
	fbInlet03Error.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbInlet03Error.i_pxAcknowledge			:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbInlet03Error.i_pxInitCoreDone			:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbInlet03Error.i_xAutoAck				:= FALSE;
END_IF

IF axAxisPresent[CST_Inlet04] THEN
	fbInlet04Error.i_psAlarmName			:= ADR('OutInlet04AxisError');
	fbInlet04Error.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbInlet04Error.i_pxAcknowledge			:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbInlet04Error.i_pxInitCoreDone			:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbInlet04Error.i_xAutoAck				:= FALSE;
END_IF	

IF axAxisPresent[CST_Outlet01] THEN
	fbOutlet01Error.i_psAlarmName			:= ADR('OutOutlet01AxisError');
	fbOutlet01Error.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbOutlet01Error.i_pxAcknowledge			:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbOutlet01Error.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbOutlet01Error.i_xAutoAck				:= FALSE;
END_IF

IF axAxisPresent[CST_Outlet02] THEN
	fbOutlet02Error.i_psAlarmName			:= ADR('OutOutlet02AxisError');
	fbOutlet02Error.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbOutlet02Error.i_pxAcknowledge			:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbOutlet02Error.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbOutlet02Error.i_xAutoAck				:= FALSE;
END_IF

IF axAxisPresent[CST_Outlet03] THEN
	fbOutlet03Error.i_psAlarmName			:= ADR('OutOutlet03AxisError');
	fbOutlet03Error.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbOutlet03Error.i_pxAcknowledge			:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbOutlet03Error.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbOutlet03Error.i_xAutoAck				:= FALSE;
END_IF

IF axAxisPresent[CST_Outlet04] THEN
	fbOutlet04Error.i_psAlarmName			:= ADR('OutOutlet04AxisError');
	fbOutlet04Error.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbOutlet04Error.i_pxAcknowledge			:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbOutlet04Error.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbOutlet04Error.i_xAutoAck				:= FALSE;
END_IF

(* Lag error exceptions *)
fbMainAxisLagError.i_psAlarmName			:= ADR('OutletMainLag');
fbMainAxisLagError.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
fbMainAxisLagError.i_pxAcknowledge			:= ADR(stOutletModule.iq_stCmd.i_xReset);
fbMainAxisLagError.i_pxInitCoreDone			:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
fbMainAxisLagError.i_xAutoAck				:= TRUE;

IF axAxisPresent[CST_Inlet01] THEN
	fbInlet01LagError.i_psAlarmName			:= ADR('OutInlet01Lag');
	fbInlet01LagError.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbInlet01LagError.i_pxAcknowledge		:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbInlet01LagError.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbInlet01LagError.i_xAutoAck			:= TRUE;
END_IF
	
IF axAxisPresent[CST_Inlet02] THEN
	fbInlet02LagError.i_psAlarmName			:= ADR('OutInlet02Lag');
	fbInlet02LagError.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbInlet02LagError.i_pxAcknowledge		:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbInlet02LagError.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbInlet02LagError.i_xAutoAck			:= TRUE;
END_IF

IF axAxisPresent[CST_Inlet03] THEN
	fbInlet03LagError.i_psAlarmName			:= ADR('OutInlet03Lag');
	fbInlet03LagError.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbInlet03LagError.i_pxAcknowledge		:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbInlet03LagError.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbInlet03LagError.i_xAutoAck			:= TRUE;
END_IF
	
IF axAxisPresent[CST_Inlet04] THEN
	fbInlet04LagError.i_psAlarmName			:= ADR('OutInlet04Lag');
	fbInlet04LagError.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
	fbInlet04LagError.i_pxAcknowledge		:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbInlet04LagError.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbInlet04LagError.i_xAutoAck			:= TRUE;
END_IF

IF axAxisPresent[CST_Outlet01] THEN
	fbOutlet01LagError.i_psAlarmName		:= ADR('OutOutlet01Lag');
	fbOutlet01LagError.i_pstMpAlarmXLink	:= ADR(gOutletAlarmXCoreLink);
	fbOutlet01LagError.i_pxAcknowledge		:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbOutlet01LagError.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbOutlet01LagError.i_xAutoAck			:= TRUE;
END_IF

IF axAxisPresent[CST_Outlet02] THEN
	fbOutlet02LagError.i_psAlarmName		:= ADR('OutOutlet02Lag');
	fbOutlet02LagError.i_pstMpAlarmXLink	:= ADR(gOutletAlarmXCoreLink);
	fbOutlet02LagError.i_pxAcknowledge		:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbOutlet02LagError.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbOutlet02LagError.i_xAutoAck			:= TRUE;
END_IF

IF axAxisPresent[CST_Outlet03] THEN
	fbOutlet03LagError.i_psAlarmName		:= ADR('OutOutlet03Lag');
	fbOutlet03LagError.i_pstMpAlarmXLink	:= ADR(gOutletAlarmXCoreLink);
	fbOutlet03LagError.i_pxAcknowledge		:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbOutlet03LagError.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbOutlet03LagError.i_xAutoAck			:= TRUE;
END_IF

IF axAxisPresent[CST_Outlet04] THEN
	fbOutlet04LagError.i_psAlarmName		:= ADR('OutOutlet04Lag');
	fbOutlet04LagError.i_pstMpAlarmXLink	:= ADR(gOutletAlarmXCoreLink);
	fbOutlet04LagError.i_pxAcknowledge		:= ADR(stOutletModule.iq_stCmd.i_xReset);
	fbOutlet04LagError.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
	fbOutlet04LagError.i_xAutoAck			:= TRUE;
END_IF

(* Emergency stop event *)
fbEmergencyStopAlarm.i_psAlarmName			:= ADR('EmergencyStop');
fbEmergencyStopAlarm.i_pstMpAlarmXLink		:= ADR(gOutletAlarmXCoreLink);
fbEmergencyStopAlarm.i_pxAcknowledge		:= ADR(stOutletModule.iq_stCmd.i_xReset);
fbEmergencyStopAlarm.i_pxInitCoreDone		:= ADR(stOutletModule.iq_stCmd.i_xAlarmInitOk);
fbEmergencyStopAlarm.i_xAutoAck				:= TRUE;

(* Module Stopped Memory *)
stOutletModule.iq_stStatus.q_xModuleStopped	:= TRUE;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION
(* @LANGUAGE := 'st' *)
(****** TOKEN RING ARRAY INITIALIZATION ******)
uiAxisIndex := 0;

IF axAxisPresent[CST_Inlet04] THEN
	auiAxisTokenList[uiAxisIndex] := CST_Inlet04;
	uiAxisIndex	:= uiAxisIndex + 1;
END_IF
	
IF axAxisPresent[CST_Inlet03] THEN
	auiAxisTokenList[uiAxisIndex] := CST_Inlet03;
	uiAxisIndex	:= uiAxisIndex + 1;
END_IF
	
IF axAxisPresent[CST_Inlet02] THEN
	auiAxisTokenList[uiAxisIndex] := CST_Inlet02;
	uiAxisIndex	:= uiAxisIndex + 1;
END_IF
	
IF axAxisPresent[CST_Inlet01] THEN
	auiAxisTokenList[uiAxisIndex] := CST_Inlet01;
	uiAxisIndex	:= uiAxisIndex + 1;
END_IF
	
auiAxisTokenList[uiAxisIndex] := CST_MainAxis;
uiAxisIndex	:= uiAxisIndex + 1;
	
IF axAxisPresent[CST_Outlet01] THEN
	auiAxisTokenList[uiAxisIndex] := CST_Outlet01;
	uiAxisIndex	:= uiAxisIndex + 1;
END_IF
	
IF axAxisPresent[CST_Outlet02] THEN
	auiAxisTokenList[uiAxisIndex] := CST_Outlet02;
	uiAxisIndex	:= uiAxisIndex + 1;
END_IF
	
IF axAxisPresent[CST_Outlet03] THEN
	auiAxisTokenList[uiAxisIndex] := CST_Outlet03;
	uiAxisIndex	:= uiAxisIndex + 1;
END_IF
	
IF axAxisPresent[CST_Outlet04] THEN
	auiAxisTokenList[uiAxisIndex] := CST_Outlet04;
	uiAxisIndex	:= uiAxisIndex + 1;
END_IF
END_ACTION
TRANSITION FROM InitModule TO WaitInitDone:=
stOutletModule.iq_stCmd.i_xMachineInitDone
END_TRANSITION
(* @SFCNOJUMP := 'WaitInitDone' *)
STEP WaitInitDone:
(* @LANGUAGE := 'st' *)
FOR uiAxisIndex := CST_ModuleMasterAxis TO CST_LastOutletModuleAxis BY 1 DO
	(******* Reset Command To All Axes ********)
	(* Reset *)
	stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xErrorReset	:= stOutletModule.iq_stCmd.i_xReset;
END_FOR

(* Sub Modules calls for init *)
IF axAxisPresent[CST_MainAxis] THEN
	fbOutletMaster;
ELSE
	stOutletModule.iq_stStatus.q_xModuleReal	:= FALSE;
	stOutletModule.iq_stStatus.q_xInitDone		:= TRUE;
	RETURN;
END_IF

CASE uiAxisToken OF
	CST_MainAxis:
		fbMain;
		IF (stOutletModule.iq_astSubModuleAxis[uiAxisToken].iq_stStatus.q_stMainAxisStatus.q_xInitDone) THEN
			uiAxisToken	:= CST_Inlet01;
		END_IF
	
	CST_Inlet01:
		IF axAxisPresent[CST_Inlet01] THEN
			fbInlet01;
			IF (stOutletModule.iq_astSubModuleAxis[uiAxisToken].iq_stStatus.q_stMainAxisStatus.q_xInitDone) THEN
				uiAxisToken	:= CST_Inlet02;
			END_IF
		ELSE
			uiAxisToken	:= CST_Inlet02;
		END_IF
	
	CST_Inlet02:
		IF axAxisPresent[CST_Inlet02] THEN
			fbInlet02;
			IF (stOutletModule.iq_astSubModuleAxis[uiAxisToken].iq_stStatus.q_stMainAxisStatus.q_xInitDone) THEN
				uiAxisToken	:= CST_Inlet03;
			END_IF
		ELSE
			uiAxisToken	:= CST_Inlet03;
		END_IF
	
	CST_Inlet03:
		IF axAxisPresent[CST_Inlet03] THEN
			fbInlet03;
			IF (stOutletModule.iq_astSubModuleAxis[uiAxisToken].iq_stStatus.q_stMainAxisStatus.q_xInitDone) THEN
				uiAxisToken	:= CST_Inlet04;
			END_IF
		ELSE
			uiAxisToken	:= CST_Inlet04;
		END_IF
	
	CST_Inlet04:
		IF axAxisPresent[CST_Inlet04] THEN
			fbInlet04;
			IF (stOutletModule.iq_astSubModuleAxis[uiAxisToken].iq_stStatus.q_stMainAxisStatus.q_xInitDone) THEN
				uiAxisToken	:= CST_Outlet01;
			END_IF
		ELSE
			uiAxisToken	:= CST_Outlet01;
		END_IF

	CST_Outlet01:
		IF axAxisPresent[CST_Outlet01] THEN
			fbOutlet01;
			IF (stOutletModule.iq_astSubModuleAxis[uiAxisToken].iq_stStatus.q_stMainAxisStatus.q_xInitDone) THEN
				uiAxisToken	:= CST_Outlet02;
			END_IF
		ELSE
			uiAxisToken := CST_Outlet02;
		END_IF

	CST_Outlet02:
		IF axAxisPresent[CST_Outlet02] THEN
			fbOutlet02;
			IF (stOutletModule.iq_astSubModuleAxis[uiAxisToken].iq_stStatus.q_stMainAxisStatus.q_xInitDone) THEN
				uiAxisToken	:= CST_Outlet03;
			END_IF
		ELSE
			uiAxisToken := CST_Outlet03;
		END_IF

	CST_Outlet03:
		IF axAxisPresent[CST_Outlet03] THEN
			fbOutlet03;
			IF (stOutletModule.iq_astSubModuleAxis[uiAxisToken].iq_stStatus.q_stMainAxisStatus.q_xInitDone) THEN
				uiAxisToken	:= CST_Outlet04;
			END_IF
		ELSE
			uiAxisToken := CST_Outlet04;
		END_IF
	
	CST_Outlet04:
		IF axAxisPresent[CST_Outlet04] THEN
			fbOutlet04;
			IF (stOutletModule.iq_astSubModuleAxis[uiAxisToken].iq_stStatus.q_stMainAxisStatus.q_xInitDone) THEN
				uiAxisToken	:= CST_MainAxis;
			END_IF
		ELSE
			uiAxisToken := CST_MainAxis;
		END_IF
	ELSE
		uiAxisToken := CST_MainAxis;
END_CASE

(* Wait for Init Conditions *)
stOutletModule.iq_stStatus.q_xInitDone	:= TRUE;

FOR uiAxisIndex := CST_FirstOutletModuleAxis TO CST_LastOutletModuleAxis BY 1 DO
	stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xDisableAxis	:= FALSE;
	stOutletModule.iq_stStatus.q_xInitDone	:= stOutletModule.iq_stStatus.q_xInitDone AND
												(stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xInitDone OR
												NOT axAxisPresent[uiAxisIndex]);
END_FOR

IF stOutletModule.iq_stStatus.q_xInitDone THEN		
	stOutletModule.iq_stStatus.q_xModuleReal := FALSE;
	stOutletModule.iq_stStatus.q_xModuleHomed := TRUE;
	FOR uiAxisIndex := CST_FirstOutletModuleAxis TO CST_LastOutletModuleAxis BY 1 DO
		stOutletModule.iq_stStatus.q_xModuleReal	:= stOutletModule.iq_stStatus.q_xModuleReal	OR
														stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xAxisReal;
		
		IF NOT stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xPowerSupply AND 
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xAxisReal			THEN
			
			stOutletModule.iq_stStatus.q_xModuleHomed	:= stOutletModule.iq_stStatus.q_xModuleHomed AND
															stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xIsHomed;
		END_IF
	END_FOR
END_IF

(* Module Stopped Memory *)
stOutletModule.iq_stStatus.q_xModuleStopped	:= TRUE;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM WaitInitDone TO (Input,ModeSelection,SubModuleCalls,SetException,Output):=
stOutletModule.iq_stStatus.q_xInitDone AND stOutletModule.iq_stStatus.q_xModuleReal
END_TRANSITION
(* @SFCNOJUMP := 'Input' *)
(* @SFCNOJUMP := 'ModeSelection' *)
(* @SFCNOJUMP := 'SubModuleCalls' *)
(* @SFCNOJUMP := 'SetException' *)
(* @SFCNOJUMP := 'Output' *)
TRANSITION FROM WaitInitDone TO Disabled:=
stOutletModule.iq_stStatus.q_xInitDone AND NOT stOutletModule.iq_stStatus.q_xModuleReal
END_TRANSITION
(* @SFCISJUMP := 'Disabled' *)
STEP Input:
(* @LANGUAGE := 'st' *)
uiSlowAxisIndex	:= (uiSlowAxisIndex + 1) MOD (CST_LastOutletModuleAxis + 1);

stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stParam.i_rStopPosition			:= stOutletModule.iq_stParameters.i_rStopPosition;
stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stParam.i_rEndlessAcceleration	:= stOutletModule.iq_stParameters.i_rEndlessAcceleration;
stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stParam.i_rEndlessDeceleration	:= stOutletModule.iq_stParameters.i_rEndlessDeceleration;

FOR uiAxisIndex := CST_ModuleMasterAxis TO CST_LastOutletModuleAxis BY 1 DO
	(******* Spread the reactions to the axes ********)
	(* Reset *)
	stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xErrorReset		:= stOutletModule.iq_stCmd.i_xReset;
	(* Quick stop *)
	stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xQuickStop		:= stOutletModule.iq_stCmd.i_xQuickStop;
	(* Emergency stop *)
	stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xEmergencyStop	:= stOutletModule.iq_stCmd.i_xEmergencyStop OR (xJogMultiActive AND NOT stOutletModule.iq_stStatus.q_xModuleStopped  AND NOT stOutletModule.iq_stCmd.i_xJogPB);
	(* Shutdown *)
	stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xShutdown		:= stOutletModule.iq_stCmd.i_xShutdown;

	(* Only for real axis *)
	IF NOT stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xPowerSupply 	AND
		stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xAxisReal			THEN
	
		(* Master *)
		IF usiMasterRequest	= LOCAL_MASTER AND usiMasterStatus <> LOCAL_MASTER THEN
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stParam.i_udiMasterLink		:= ADR(gOutletModuleMasterLink);
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stParam.i_plrMasterPosition	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stParam.i_prMasterVelocity	:= ADR(stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
		ELSIF usiMasterRequest = GLOBAL_MASTER AND usiMasterStatus <> GLOBAL_MASTER THEN
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stParam.i_udiMasterLink		:= ADR(gMasterLink);
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stParam.i_plrMasterPosition	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stParam.i_prMasterVelocity	:= ADR(VAR_Machine.stMasterModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
		END_IF
	END_IF
END_FOR	

xReactionActive	:= stOutletModule.iq_stCmd.i_xQuickStop OR stOutletModule.iq_stCmd.i_xShutdown OR stOutletModule.iq_stCmd.i_xEmergencyStop OR (xJogMultiActive AND NOT stOutletModule.iq_stStatus.q_xModuleStopped AND NOT stOutletModule.iq_stCmd.i_xJogPB);
tofReactionActive(IN := xReactionActive, PT := t#100ms);

(* Input Signals *)
xInputAuto				:= stOutletModule.iq_stCmd.i_xAutoMode;
xInputJogMulti			:= stOutletModule.iq_stCmd.i_xJogMultiMode;
xInputAutoMulti			:= stOutletModule.iq_stCmd.i_xAutoMultiMode;
xInputSelHoming			:= stOutletModule.iq_stCmd.i_xSelectiveHomingMode;
xInputVelocity			:= stOutletModule.iq_stCmd.i_xVelocityMode;
xInputPositioning		:= stOutletModule.iq_stCmd.i_xPositioningMode;
xInputThirdPartySetup	:= stOutletModule.iq_stCmd.i_xThirdPartySetup;
xInputInductionSetup	:= stOutletModule.iq_stCmd.i_xInductionSetup;
xInputSlowMotion		:= stOutletModule.iq_stCmd.i_xSlowMotionForward OR stOutletModule.iq_stCmd.i_xSlowMotionBackward;
xInputBrakeRelease		:= stOutletModule.iq_stCmd.i_xBrakeRelease;
xInputStepByStep		:= stOutletModule.iq_stCmd.i_xStepByStep;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP ModeSelection:
(* @LANGUAGE := 'st' *)
(* Operating modes bits *)
xNoOpActive				:= TRUE;
xAutoActive 			:= FALSE;
xPositioningActive 		:= FALSE;
xSelHomingActive 		:= FALSE;
xBrakeReleaseActive 	:= FALSE;
xSlowMotionActive 		:= FALSE;
xJogMultiActive 		:= FALSE;
xAutoMultiActive 		:= FALSE;
xStepByStepActive 		:= FALSE;
xThirdPartySetupActive	:= FALSE;
xInductionSetupActive	:= FALSE;

(* Change status *)
xModeReady	:= usiMasterRequest = usiMasterStatus	AND
				NOT xAutoMode 						AND
				NOT xPositioningMode 				AND
				NOT xSelectiveHomingMode			AND
				NOT xVelocityMode					AND
				NOT xPositioningMode				AND
				NOT xStepByStepMode					AND
				NOT xJogMultiMode					AND
				NOT xAutoMultiMode					AND
				NOT xSlowMotionMode					AND
				NOT xThirdPartySetupMode			AND
				NOT xInductionSetupMode				AND
				NOT tofReactionActive.Q;

IF xModeReady THEN
	(* Local Master Request *)
	IF xInputJogMulti OR xInputAutoMulti OR xInputSlowMotion THEN
		usiMasterRequest	:= LOCAL_MASTER;
	ELSIF xInputAuto OR	xInputPositioning OR xInputSelHoming OR xInputStepByStep OR xInputVelocity OR xInputThirdPartySetup OR xInputInductionSetup THEN
		usiMasterRequest	:= GLOBAL_MASTER;
	END_IF
	
	IF usiMasterStatus = GLOBAL_MASTER THEN
		IF xInputAuto THEN
			xAutoMode				:= TRUE;
		ELSIF xInputPositioning THEN
			xPositioningMode		:= TRUE;
		ELSIF xInputSelHoming THEN
			xSelectiveHomingMode	:= TRUE;
		ELSIF xInputThirdPartySetup THEN
			xThirdPartySetupMode	:= TRUE;
		ELSIF xInputInductionSetup THEN
			xInductionSetupMode		:= TRUE;
		ELSIF xInputStepByStep THEN
			xStepByStepMode			:= TRUE;
		ELSIF xInputVelocity THEN
			xVelocityMode			:= TRUE;
		END_IF
	ELSIF usiMasterStatus = LOCAL_MASTER THEN
		IF xInputJogMulti THEN
			xJogMultiMode 			:= TRUE;
		ELSIF xInputAutoMulti THEN
			xAutoMultiMode 			:= TRUE;
		ELSIF xInputSlowMotion THEN
			xSlowMotionMode			:= TRUE;
		END_IF
	END_IF
ELSIF tofReactionActive.Q THEN
	xBrakeReleaseMode	:= xInputBrakeRelease;
END_IF
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
xExitStep	:= FALSE;
uiAutoStep	:= 0;
stOutletModule.iq_stStatus.q_xMasterRephased := FALSE;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
xNoOpActive	:= FALSE;
END_ACTION
TRANSITION FROM ModeSelection TO Auto:=
xAutoMode
END_TRANSITION
(* @SFCNOJUMP := 'Auto' *)
TRANSITION FROM ModeSelection TO Positioning:=
xPositioningMode
END_TRANSITION
(* @SFCNOJUMP := 'Positioning' *)
STEP Positioning:
(* @LANGUAGE := 'st' *)
IF xReactionActive OR NOT xInputPositioning THEN
	xPositioningMode	:= FALSE;
END_IF

xPositioningActive	:= TRUE;

CASE uiPositioningStep OF
	0:
		IF stOutletModule.iq_stStatus.q_xRealAxesReadyForACommand AND stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xReadyForACommand THEN
			IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset THEN
				uiPositioningStep	:= 100;
			ELSE
				uiPositioningStep	:= 50;
			END_IF
		END_IF
	
	50:
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation := stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xSynchroWithOffset;
		END_FOR

		IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset THEN
			uiPositioningStep := 60;
		END_IF

	60:
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation := FALSE;
		END_FOR
		uiPositioningStep := 100;
	
	100:
		IF stOutletModule.iq_stParameters.i_uiAxisSelected >= uiFirstOutletModuleAxis AND stOutletModule.iq_stParameters.i_uiAxisSelected <= uiLastOutletModuleAxis THEN
			uiOldAxisSelected := stOutletModule.iq_stParameters.i_uiAxisSelected;
			IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xAxisReal THEN
				uiPositioningStep := 110;
			END_IF
		END_IF
	
	110:	
		stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stParam.i_rPositioningVelocity	:= CST_PositioningVel;
		stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stParam.i_rPositioningAccDec	:= CST_PositioningAccDec;
		stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stParam.i_lrAdditiveDistance	:= stOutletModule.iq_stParameters.i_rPositioningOffset;

		IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stParam.i_lrAdditiveDistance = 0 THEN
			stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stParam.i_lrAdditiveDistance := 360.0;
		END_IF
		
		stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xMoveAdditive	:= TRUE;

		tonPositDone(IN := FALSE, PT := T#1s);
		uiPositioningStep := 120;
		
	120:
		tonPositDone(IN := TRUE, PT := T#1s);
		IF NOT stOutletModule.iq_stStatus.q_xModuleStopped OR tonPositDone.Q THEN
			uiPositioningStep := 130;
		END_IF
	
	130:
		IF stOutletModule.iq_stStatus.q_xModuleStopped THEN
			stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xMoveAdditive	:= FALSE;
			uiPositioningStep := 140;
		END_IF
	
	140:
		stOutletModule.iq_stStatus.q_xPositioningDone := TRUE;
END_CASE
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
uiPositioningStep	:= 0;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
stOutletModule.iq_stStatus.q_xPositioningDone := FALSE;
END_ACTION
TRANSITION FROM Positioning TO PositExit:=
NOT xPositioningMode
END_TRANSITION
(* @SFCNOJUMP := 'PositExit' *)
STEP PositExit:
(* @LANGUAGE := 'st' *)
stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xMoveAdditive	:= FALSE;
stOutletModule.iq_stStatus.q_xPositioningDone := FALSE;
xExitStep := TRUE;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM PositExit TO ModeSelection:=
xExitStep
END_TRANSITION
(* @SFCISJUMP := 'ModeSelection' *)
TRANSITION FROM ModeSelection TO Velocity:=
xVelocityMode
END_TRANSITION
(* @SFCNOJUMP := 'Velocity' *)
STEP Velocity:
(* @LANGUAGE := 'st' *)
IF xReactionActive OR NOT xInputVelocity THEN
	xVelocityMode	:= FALSE;
END_IF

xVelocityActive	:= TRUE;

CASE uiVelocityStep OF
	0:
		IF stOutletModule.iq_stStatus.q_xRealAxesReadyForACommand THEN
			uiVelocityStep	:= 100;
		END_IF
	
	100:
		IF stOutletModule.iq_stParameters.i_uiAxisSelected >= uiFirstOutletModuleAxis AND stOutletModule.iq_stParameters.i_uiAxisSelected <= uiLastOutletModuleAxis THEN
			uiOldAxisSelected	:= stOutletModule.iq_stParameters.i_uiAxisSelected;
			IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xAxisReal THEN
				uiVelocityStep	:= 110;
			END_IF
		END_IF
	
	110:
		stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stParam.i_rEndlessVelocity		:= stOutletModule.iq_stParameters.i_rManualVelocity;

		stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stParam.i_lrAdditiveDistance	:= stOutletModule.iq_stParameters.i_rPositioningOffset;
		stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xMoveVelocity			:= stOutletModule.iq_stCmd.i_xStart;
		uiVelocityStep	:= 120;
		
	120:
END_CASE
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
uiVelocityStep	:= 0;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
xVelocityActive		:= FALSE;
uiOldAxisSelected	:= LIMIT(CST_FirstOutletModuleAxis, uiOldAxisSelected, CST_LastOutletModuleAxis);
stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xMoveVelocity	:= FALSE;
END_ACTION
TRANSITION FROM Velocity TO VelExit:=
NOT xVelocityMode
END_TRANSITION
(* @SFCNOJUMP := 'VelExit' *)
STEP VelExit:
(* @LANGUAGE := 'st' *)
xExitStep	:= stOutletModule.iq_stStatus.q_xModuleStopped;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM VelExit TO ModeSelection:=
xExitStep
END_TRANSITION
(* @SFCISJUMP := 'ModeSelection' *)
TRANSITION FROM ModeSelection TO SelHome:=
xSelectiveHomingMode
END_TRANSITION
(* @SFCNOJUMP := 'SelHome' *)
STEP SelHome:
(* @LANGUAGE := 'st' *)
IF xReactionActive OR NOT xInputSelHoming THEN
	xSelectiveHomingMode := FALSE;
END_IF

xSelHomingActive	:= TRUE;

CASE uiSelectiveHomeStep OF
	0:	
		IF stOutletModule.iq_stParameters.i_uiAxisSelected >= uiFirstOutletModuleAxis AND stOutletModule.iq_stParameters.i_uiAxisSelected <= uiLastOutletModuleAxis THEN
			uiOldAxisSelected	:= stOutletModule.iq_stParameters.i_uiAxisSelected;
			IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xAxisReal THEN
				uiSelectiveHomeStep	:= 10;
			END_IF
		END_IF
	
	10:
		stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xHome	:= TRUE;
		IF NOT stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xIsHomed THEN
			uiSelectiveHomeStep	:= 20;
		END_IF
		
	20:
		uiSelectiveHomeStep	:= 30;
	
	30:
		IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xIsHomed THEN
			stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xHome	:= FALSE;
			uiSelectiveHomeStep	:= 40;
		END_IF

	40:
		stOutletModule.iq_stStatus.q_xSelHomingDone := TRUE;
END_CASE
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
uiSelectiveHomeStep	:= 0;

(* Selective Homing done *)
stOutletModule.iq_stStatus.q_xSelHomingDone := FALSE;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
(* Selective Homing done *)
stOutletModule.iq_stStatus.q_xSelHomingDone := FALSE;
END_ACTION
TRANSITION FROM SelHome TO SelHomeExit:=
NOT xSelectiveHomingMode
END_TRANSITION
(* @SFCNOJUMP := 'SelHomeExit' *)
STEP SelHomeExit:
(* @LANGUAGE := 'st' *)
stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xHome	:= FALSE;
xExitStep	:= TRUE;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM SelHomeExit TO ModeSelection:=
xExitStep
END_TRANSITION
(* @SFCISJUMP := 'ModeSelection' *)
TRANSITION FROM ModeSelection TO Brake:=
xBrakeReleaseMode
END_TRANSITION
(* @SFCNOJUMP := 'Brake' *)
STEP Brake:
(* @LANGUAGE := 'st' *)
xBrakeReleaseActive	:= TRUE;

IF NOT xInputBrakeRelease THEN
	xBrakeReleaseMode	:= FALSE;
END_IF

xBrakeReleaseActive	:= TRUE;

CASE uiBrakeReleaseStep OF
	0:
		uiOldAxisSelected	:= 0;
		IF stOutletModule.iq_stParameters.i_uiAxisSelected >= uiFirstOutletModuleAxis AND stOutletModule.iq_stParameters.i_uiAxisSelected <= uiLastOutletModuleAxis THEN
			uiOldAxisSelected	:= stOutletModule.iq_stParameters.i_uiAxisSelected;
			IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xAxisReal THEN
				IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xMotorWithBrake THEN
					uiBrakeReleaseStep	:= 100;
				ELSE
					uiBrakeReleaseStep	:= 400;
				END_IF
			END_IF
		END_IF

	100:
		stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xReleaseBrake	:= TRUE;
		IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xBrakeReleased THEN
			uiBrakeReleaseStep	:= 200;
		END_IF

	200:
		stOutletModule.iq_stStatus.q_xBrakeReleaseDone	:= TRUE;			
	
	400:
		stOutletModule.iq_stStatus.q_xBrakeReleaseDone	:= TRUE;
END_CASE
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
uiBrakeReleaseStep	:= 0;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
xBrakeReleaseActive	:= FALSE;
stOutletModule.iq_stStatus.q_xBrakeReleaseDone	:= FALSE;

IF uiOldAxisSelected <> 0 THEN
	stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xReleaseBrake	:= FALSE;
END_IF
END_ACTION
TRANSITION FROM Brake TO BrakeExit:=
NOT xBrakeReleaseMode
END_TRANSITION
(* @SFCNOJUMP := 'BrakeExit' *)
STEP BrakeExit:
(* @LANGUAGE := 'st' *)
xExitStep	:= TRUE;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM BrakeExit TO ModeSelection:=
xExitStep
END_TRANSITION
(* @SFCISJUMP := 'ModeSelection' *)
TRANSITION FROM ModeSelection TO ThirdPartySetup:=
xThirdPartySetupMode
END_TRANSITION
(* @SFCNOJUMP := 'ThirdPartySetup' *)
STEP ThirdPartySetup:
(* @LANGUAGE := 'st' *)
IF xReactionActive OR NOT xInputThirdPartySetup THEN
	xThirdPartySetupMode	:= FALSE;
END_IF

xThirdPartySetupActive	:= TRUE;

CASE uiThirdPartySetupStep OF
	0:	
		IF stOutletModule.iq_stParameters.i_uiAxisSelected >= uiFirstOutletModuleAxis AND stOutletModule.iq_stParameters.i_uiAxisSelected <= uiLastOutletModuleAxis THEN
			uiOldAxisSelected	:= stOutletModule.iq_stParameters.i_uiAxisSelected;
			IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xAxisReal AND stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xThirdPartyMotor THEN
				uiThirdPartySetupStep	:= 10;
			ELSE
				uiThirdPartySetupStep	:= 40;
			END_IF
		END_IF
	
	10:	
		stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xThirdPartySetup	:= TRUE;
		IF NOT stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xMotorSetupDone THEN
			uiThirdPartySetupStep	:= 20;
		END_IF
		
	20:
		IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xMotorSetupDone THEN
			stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xThirdPartySetup	:= FALSE;
			uiThirdPartySetupStep	:= 40;
		END_IF

	40:
		stOutletModule.iq_stStatus.q_xThirdPartySetupDone := TRUE;
END_CASE
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
uiThirdPartySetupStep	:= 0;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
stOutletModule.iq_stStatus.q_xThirdPartySetupDone := FALSE;
END_ACTION
TRANSITION FROM ThirdPartySetup TO ThirdPartySetupExit:=
NOT xThirdPartySetupMode
END_TRANSITION
(* @SFCNOJUMP := 'ThirdPartySetupExit' *)
STEP ThirdPartySetupExit:
(* @LANGUAGE := 'st' *)
stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xThirdPartySetup	:= FALSE;
stOutletModule.iq_stStatus.q_xThirdPartySetupDone := FALSE;
stOutletModule.iq_stStatus.q_xThirdPartySetupActive := FALSE;
xExitStep := TRUE;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM ThirdPartySetupExit TO ModeSelection:=
xExitStep
END_TRANSITION
(* @SFCISJUMP := 'ModeSelection' *)
TRANSITION FROM ModeSelection TO InductionSetup:=
xInductionSetupMode
END_TRANSITION
(* @SFCNOJUMP := 'InductionSetup' *)
STEP InductionSetup:
(* @LANGUAGE := 'st' *)
IF xReactionActive OR NOT xInputInductionSetup THEN
	xInductionSetupMode	:= FALSE;
END_IF

xInductionSetupActive	:= TRUE;

CASE uiInductionSetupStep OF
	0:	
		IF stOutletModule.iq_stParameters.i_uiAxisSelected >= uiFirstOutletModuleAxis AND stOutletModule.iq_stParameters.i_uiAxisSelected <= uiLastOutletModuleAxis THEN
			uiOldAxisSelected	:= stOutletModule.iq_stParameters.i_uiAxisSelected;
			IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xAxisReal AND stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xThirdPartyMotor THEN
				uiInductionSetupStep	:= 10;
			ELSE
				uiInductionSetupStep	:= 40;
			END_IF
		END_IF
	
	10:	
		stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xInductionMotorSetup	:= TRUE;
		IF NOT stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xMotorSetupDone THEN
			uiInductionSetupStep	:= 20;
		END_IF
		
	20:
		IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xMotorSetupDone THEN
			stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xInductionMotorSetup	:= FALSE;
			uiInductionSetupStep	:= 40;
		END_IF

	40:
		stOutletModule.iq_stStatus.q_xInductionSetupDone := TRUE;
END_CASE
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
uiInductionSetupStep	:= 0;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
stOutletModule.iq_stStatus.q_xInductionSetupDone := FALSE;
END_ACTION
TRANSITION FROM InductionSetup TO InductionSetupExit1:=
NOT xInductionSetupMode
END_TRANSITION
(* @SFCNOJUMP := 'InductionSetupExit1' *)
STEP InductionSetupExit1:
(* @LANGUAGE := 'st' *)
stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xInductionMotorSetup	:= FALSE;
stOutletModule.iq_stStatus.q_xInductionSetupDone := FALSE;
stOutletModule.iq_stStatus.q_xInductionSetupActive := FALSE;
xExitStep := TRUE;
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM InductionSetupExit1 TO ModeSelection:=
xExitStep
END_TRANSITION
(* @SFCISJUMP := 'ModeSelection' *)
TRANSITION FROM ModeSelection TO SlowMotion:=
xSlowMotionMode
END_TRANSITION
(* @SFCNOJUMP := 'SlowMotion' *)
STEP SlowMotion:
(* @LANGUAGE := 'st' *)
IF xReactionActive OR NOT (stOutletModule.iq_stCmd.i_xSlowMotionForward OR stOutletModule.iq_stCmd.i_xSlowMotionBackward) THEN
	xSlowMotionMode	:= FALSE;
END_IF

xSlowMotionActive	:= TRUE;

CASE uiSlowMotionStep OF
	0:
		IF stOutletModule.iq_stCmd.i_xSlowMotionForward OR stOutletModule.iq_stCmd.i_xSlowMotionBackward THEN
			uiSlowMotionStep	:= 20;
		END_IF
	
	20:
		IF stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stStatus.q_stMainAxisStatus.q_xReadyForACommand THEN
			uiSlowMotionStep	:= 100;
		END_IF
			
	100:
		stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_rSlowMotionVelocity		:= CST_SlowMotionVelocity;
		stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_rSlowMotionAcceleration	:= CST_SlowMotionAcceleration;
		stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stParam.i_rSlowMotionDeceleration	:= CST_SlowMotionDeceleration;
		
		stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stCmd.i_xSlowMotionFwd	:= stOutletModule.iq_stCmd.i_xSlowMotionForward	AND NOT stOutletModule.iq_stCmd.i_xSlowMotionBackward AND stOutletModule.iq_stCmd.i_xJogPB;
		
		stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stCmd.i_xSlowMotionBwd	:= stOutletModule.iq_stCmd.i_xSlowMotionBackward	AND NOT stOutletModule.iq_stCmd.i_xSlowMotionForward AND stOutletModule.iq_stCmd.i_xJogPB;
END_CASE
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
uiSlowMotionStep	:= 0;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stCmd.i_xSlowMotionFwd	:= FALSE;
stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stCmd.i_xSlowMotionBwd	:= FALSE;
xSlowMotionActive	:= FALSE;
END_ACTION
TRANSITION FROM SlowMotion TO SlowMotionExit:=
NOT xSlowMotionMode
END_TRANSITION
(* @SFCNOJUMP := 'SlowMotionExit' *)
STEP SlowMotionExit:
(* @LANGUAGE := 'st' *)
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xSlowMotionBwd	:= FALSE;	
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xSlowMotionFwd	:= FALSE;

IF stOutletModule.iq_stStatus.q_xModuleStopped THEN
	FOR uiAxisIndex	:= CST_ModuleMasterAxis TO CST_LastOutletModuleAxis BY 1 DO
		stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear 				:= FALSE;
		stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation	:= FALSE;
	END_FOR
	xExitStep := NOT stOutletModule.iq_stStatus.q_xModuleSynchronized;
END_IF
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM SlowMotionExit TO ModeSelection:=
xExitStep
END_TRANSITION
(* @SFCISJUMP := 'ModeSelection' *)
TRANSITION FROM ModeSelection TO JogMulti:=
xJogMultiMode
END_TRANSITION
(* @SFCNOJUMP := 'JogMulti' *)
STEP JogMulti:
(* @LANGUAGE := 'st' *)
IF xReactionActive OR NOT xInputJogMulti THEN
	xJogMultiMode	:= FALSE;
END_IF

xJogMultiActive	:= TRUE;

CASE uiJogMulti OF
	0:
		IF stOutletModule.iq_stStatus.q_xRealAxesReadyForACommand AND stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xReadyForACommand THEN
			IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset THEN
				uiJogMulti	:= 100;
			ELSE
				uiJogMulti	:= 50;
			END_IF
		END_IF
	
	50:
		FOR uiAxisIndex	:= 	uiFirstOutletModuleAxis	TO uiLastOutletModuleAxis BY 1 DO
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation := stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xSynchroWithOffset;
		END_FOR
		uiJogMulti	:= 60;
	
	60:
		IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset THEN
			uiJogMulti	:= 70;
		END_IF
		
	70:
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis	TO uiLastOutletModuleAxis BY 1 DO
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation := FALSE;
		END_FOR
		uiJogMulti	:= 100;
		
	100:
		IF NOT stOutletModule.iq_stCmd.i_xStart THEN
			IF stOutletModule.iq_stCmd.i_xMasterRephasingRequest THEN
				stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xHome	:= TRUE;
				uiJogMulti	:= 105;
			END_IF
		END_IF
	
	105:
		IF NOT stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xIsHomed THEN
			uiJogMulti	:= 110;
		END_IF
	
	110:
		IF stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xIsHomed THEN
			stOutletModule.iq_stStatus.q_xMasterRephased								:= TRUE;
			stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xHome	:= FALSE;
			uiJogMulti	:= 120;
		END_IF

	120:
		IF stOutletModule.iq_stCmd.i_xJogPB THEN
			FOR uiAxisIndex	:=uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
				stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xAxisReal;
			END_FOR
			uiJogMulti	:= 130;
		END_IF
	
	130:
		(* Wait for real axes synchronized *)
		IF stOutletModule.iq_stStatus.q_xRealAxesSynchronized THEN
			uiJogMulti	:= 140;
		END_IF

	140:(* Step JOG MULTI *)
		stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_rJogVelocity	:= MAX(1, stOutletModule.iq_stParameters.i_rJogVelocity);
		stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xJogPositive	:= stOutletModule.iq_stCmd.i_xJogPB;
		
		IF NOT stOutletModule.iq_stCmd.i_xJogPB THEN
			uiJogMulti	:= 150;
		END_IF

	150:
END_CASE
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
uiJogMulti	:= 0;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
stOutletModule.iq_stStatus.q_xMasterRephased										:= FALSE;
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xJogPositive	:= FALSE;
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xHome			:= FALSE;
END_ACTION
TRANSITION FROM JogMulti TO JogExit:=
NOT xJogMultiMode
END_TRANSITION
(* @SFCNOJUMP := 'JogExit' *)
STEP JogExit:
(* @LANGUAGE := 'st' *)
(* All axis commands are set to FALSE *)
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xMoveVelocity	:= FALSE;
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xJogPositive	:= FALSE;
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xQuickStop		:= TRUE;
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xHome			:= FALSE;

(* Axis Stopped all real axis are set in GearOut mode *)
IF stOutletModule.iq_stStatus.q_xModuleStopped THEN
	stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xQuickStop	:= FALSE;
	FOR uiAxisIndex	:= CST_FirstOutletModuleAxis TO CST_LastOutletModuleAxis BY 1 DO
		stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear 				:= FALSE;
		stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation	:= FALSE;
	END_FOR
	xExitStep	:= NOT stOutletModule.iq_stStatus.q_xRealAxesSynchronized;
END_IF
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM JogExit TO ModeSelection:=
xExitStep
END_TRANSITION
(* @SFCISJUMP := 'ModeSelection' *)
TRANSITION FROM ModeSelection TO AutoMulti:=
xAutoMultiMode
END_TRANSITION
(* @SFCNOJUMP := 'AutoMulti' *)
STEP AutoMulti:
(* @LANGUAGE := 'st' *)
IF xReactionActive OR NOT xInputAutoMulti THEN
	xAutoMultiMode	:= FALSE;
END_IF

xAutoMultiActive	:= TRUE;

CASE uiAutoMulti OF
	0:
		IF stOutletModule.iq_stStatus.q_xRealAxesReadyForACommand AND stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xReadyForACommand THEN
			IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset  THEN
				uiAutoMulti	:= 100;
			ELSE
				uiAutoMulti	:= 50;
			END_IF
		END_IF
		
	50:
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation := stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xSynchroWithOffset;
		END_FOR
		uiAutoMulti	:= 60;
	
	60:
		IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset THEN
			uiAutoMulti	:= 70;
		END_IF
		
	70:
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation := FALSE;
		END_FOR
		uiAutoMulti	:= 100;
			
	100:
		IF stOutletModule.iq_stCmd.i_xMasterRephasingRequest THEN
			uiAutoMulti	:= 105;
		END_IF
	
	105:
		stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xHome := TRUE;
		uiAutoMulti	:= 110;

	110:
		stOutletModule.iq_stStatus.q_xMasterRephased :=	TRUE;
		uiAutoMulti	:= 115;
	
	115:
		IF stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xIsHomed THEN
			stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xHome := FALSE;
			uiAutoMulti	:= 120;
		END_IF
	
	120:
		IF stOutletModule.iq_stCmd.i_xStart THEN
			FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
				IF NOT stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xVelocityControl THEN
					stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xAxisReal;
				ELSE
					stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := NOT stOutletModule.iq_stCmd.i_xVelocityAxisStop;
				END_IF
			END_FOR
		END_IF
		
		(* Wait for real axes synchronized *)
		IF stOutletModule.iq_stStatus.q_xRealAxesSynchronized THEN
			uiAutoMulti	:= 130;
		END_IF
	
	130:
		IF stOutletModule.iq_stStatus.q_xSynchroWithOffset AND stOutletModule.iq_stCmd.i_xPhaseCompensation THEN
			uiAutoMulti	:= 300;
		ELSIF stOutletModule.iq_stCmd.i_xStart THEN
			uiAutoMulti	:= 140;
		END_IF
			
	140:(* Step AUTO MULTI *)
		stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_rEndlessVelocity	:= MAX(1, stOutletModule.iq_stParameters.i_rEndlessVelocity);
		stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xMoveVelocity		:= stOutletModule.iq_stCmd.i_xStart;
	
		IF NOT stOutletModule.iq_stCmd.i_xStart THEN
			uiAutoMulti	:= 150;
		ELSIF NOT stOutletModule.iq_stStatus.q_xModuleStopped THEN
			uiOldAxisSelected := LIMIT(uiFirstOutletModuleAxis, stOutletModule.iq_stParameters.i_uiAxisSelected, uiLastOutletModuleAxis);
			IF stOutletModule.iq_stParameters.i_uiAxisSelected >=  uiFirstOutletModuleAxis 	AND 
				stOutletModule.iq_stParameters.i_uiAxisSelected <=	uiLastOutletModuleAxis 	AND
				stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xAxisReal THEN
				IF stOutletModule.iq_stCmd.i_xOnePitchShift THEN
					stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xOnePitchShift := TRUE;
					uiAutoMulti	:= 160;
				ELSIF stOutletModule.iq_stCmd.i_xPhaseShift AND stOutletModule.iq_stParameters.i_rPhaseShiftDistance <> 0 THEN	
					stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stParam.i_rPhaseShiftDistance	:= stOutletModule.iq_stParameters.i_rPhaseShiftDistance;
					stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xPhaseShift			:= TRUE;
					uiAutoMulti	:= 180;
				END_IF
			END_IF
		END_IF
	
	150:
		IF stOutletModule.iq_stStatus.q_xModuleStopped THEN
			uiAutoMulti	:= 130;
		END_IF
	
	160:(* One pitch shift *)
		IF NOT stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xPhaseShiftDone AND NOT stOutletModule.iq_stCmd.i_xOnePitchShift THEN
			stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xOnePitchShift := FALSE;
			uiAutoMulti	:= 140;
		END_IF

	180:(* Phase shift *)
		IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xPhaseShiftDone AND NOT stOutletModule.iq_stCmd.i_xPhaseShift THEN
			stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xPhaseShift 	:= FALSE;
			uiAutoMulti	:= 140;
		END_IF
		
	300:(* Phase Offset Compensations *)
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
			IF stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xSynchroWithOffset THEN
				stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear 				:= FALSE;
				stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation	:= TRUE;
			END_IF
		END_FOR
		uiAutoMulti	:= 310;
	
	310:
		IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset THEN
			FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
				IF NOT stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xVelocityControl THEN
					stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xAxisReal;
				ELSE
					stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := NOT stOutletModule.iq_stCmd.i_xVelocityAxisStop;
				END_IF
				stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation	:= FALSE;
			END_FOR
			uiAutoMulti := 130;
		END_IF
END_CASE

IF uiAutoStep > 120 AND EDGE(stOutletModule.iq_stCmd.i_xVelocityAxisStop) THEN
	FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
		IF stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xVelocityControl THEN
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := NOT stOutletModule.iq_stCmd.i_xVelocityAxisStop;
		END_IF
	END_FOR
END_IF
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
uiAutoMulti	:= 0;
END_ACTION
TRANSITION FROM AutoMulti TO AutoMultiExit:=
NOT xAutoMultiMode
END_TRANSITION
(* @SFCNOJUMP := 'AutoMultiExit' *)
STEP AutoMultiExit:
(* @LANGUAGE := 'st' *)
(* All axis commands are set to FALSE *)
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xMoveVelocity	:= FALSE;
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xJogPositive	:= FALSE;
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xHome			:= FALSE;

(* Axis Stopped all real axis are set in GearOut mode *)
IF stOutletModule.iq_stStatus.q_xModuleStopped THEN
	FOR uiAxisIndex	:= CST_FirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
		stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear 				:= FALSE;
		stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation	:= FALSE;
	END_FOR
	xExitStep	:= NOT stOutletModule.iq_stStatus.q_xRealAxesSynchronized;
END_IF
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM AutoMultiExit TO ModeSelection:=
xExitStep
END_TRANSITION
(* @SFCISJUMP := 'ModeSelection' *)
TRANSITION FROM ModeSelection TO StepByStep:=
xStepByStepMode
END_TRANSITION
(* @SFCNOJUMP := 'StepByStep' *)
STEP StepByStep:
(* @LANGUAGE := 'st' *)
IF xReactionActive OR NOT xInputStepByStep THEN
	xStepByStepMode	:= FALSE;
END_IF

xStepByStepActive	:= TRUE;

CASE uiStepByStep OF
	0:
		IF stOutletModule.iq_stCmd.i_xStart THEN
			uiStepByStep	:= 20;
		END_IF
	
	20:
		IF stOutletModule.iq_stStatus.q_xRealAxesReadyForACommand AND stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xReadyForACommand THEN
			IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset THEN
				uiStepByStep	:= 100;
			ELSE
				uiStepByStep	:= 50;
			END_IF
		END_IF
		
	50:
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation := stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xSynchroWithOffset;
		END_FOR

		IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset  THEN
			uiStepByStep	:= 60;
		END_IF

	60:
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation := FALSE;
		END_FOR
		
		uiStepByStep	:= 100;
	
	100:
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xAxisReal;
		END_FOR
		
		IF stOutletModule.iq_stStatus.q_xModuleSynchronized THEN
			uiStepByStep	:= 110;
		END_IF
		
	110:
		uiNumberOfSteps	:= MAX(1, stOutletModule.iq_stParameters.i_uiNumberOfSteps);
		rAxisDistance	:= LREAL_TO_REAL(stOutletModule.iq_stParameters.i_rStopPosition	- stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_lrPosition);

		IF rAxisDistance < 0.0 THEN
			rAxisDistance	:= rAxisDistance + 360.0;
		END_IF

		IF rAxisDistance < 10.0 THEN
			rAxisDistance	:= 360.0 + rAxisDistance;
		END_IF
		
		uiStepByStep	:= 120;
		
	120:
		IF stOutletModule.iq_stCmd.i_xStart THEN
			stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_rPositioningVelocity	:= CST_PositioningVel;
			stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stParam.i_rPositioningAccDec	:= CST_PositioningAccDec;
			stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xMoveAdditive			:= TRUE;
			uiStepByStep	:= 130;
		END_IF
		
	130:
		IF NOT stOutletModule.iq_stStatus.q_xModuleStopped THEN
			stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xMoveAdditive := FALSE;
			uiStepByStep	:= 140;
		END_IF
			
	140:
		IF stOutletModule.iq_stStatus.q_xModuleStopped AND stOutletModule.iq_stCmd.i_xStart THEN
			uiStepByStep	:= 110;
		END_IF
END_CASE		
		
		
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
uiStepByStep	:= 0;
END_ACTION
TRANSITION FROM StepByStep TO StepByStepExit:=
NOT xStepByStepMode
END_TRANSITION
(* @SFCNOJUMP := 'StepByStepExit' *)
STEP StepByStepExit:
(* @LANGUAGE := 'st' *)
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xMoveAdditive	:= FALSE;
IF stOutletModule.iq_stStatus.q_xModuleStopped THEN
	FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
		stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear 				:= FALSE;
		stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation	:= FALSE;
	END_FOR
	xExitStep	:= NOT stOutletModule.iq_stStatus.q_xModuleSynchronized;
END_IF
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM StepByStepExit TO ModeSelection:=
xExitStep
END_TRANSITION
(* @SFCISJUMP := 'ModeSelection' *)
STEP Auto:
(* @LANGUAGE := 'st' *)
IF xReactionActive OR NOT xInputAuto THEN
	xAutoMode	:= FALSE;
END_IF

xAutoActive	:= TRUE;

CASE uiAutoStep OF
	0:
		IF stOutletModule.iq_stStatus.q_xRealAxesReadyForACommand AND stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xReadyForACommand THEN
			IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset THEN
				uiAutoStep	:= 100;
			ELSE
				uiAutoStep	:= 50;
			END_IF
		END_IF
			
	50:
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis	TO uiLastOutletModuleAxis BY 1 DO
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation := stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xSynchroWithOffset;				
		END_FOR
		uiAutoStep	:= 60;
	
	60:
		IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset THEN
			uiAutoStep	:= 70;
		END_IF

	70:
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis	TO uiLastOutletModuleAxis BY 1 DO
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation := FALSE;
		END_FOR
		uiAutoStep	:= 0;
	
	100:
		IF stOutletModule.iq_stCmd.i_xStart THEN
			stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xHome 	:= TRUE;			
			IF NOT stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xIsHomed THEN
				stOutletModule.iq_stStatus.q_xMasterRephased := TRUE;
				uiAutoStep	:= 110;
			END_IF
		END_IF
						
	110:
		IF stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xIsHomed THEN
			stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xHome 	:= FALSE;
			uiAutoStep	:= 120;
		END_IF
	
	120:
		FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
			IF NOT stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xVelocityControl THEN
				stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xAxisReal;
			ELSE
				stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := NOT stOutletModule.iq_stCmd.i_xVelocityAxisStop;
			END_IF
		END_FOR
		
		IF stOutletModule.iq_stStatus.q_xRealAxesSynchronized THEN
			uiAutoStep	:= 130;
		END_IF
	
	130:(* If the machine is running the phasing command is taken in account *)
		IF NOT stOutletModule.iq_stStatus.q_xModuleStopped THEN
			uiOldAxisSelected	:= LIMIT(CST_FirstOutletModuleAxis, stOutletModule.iq_stParameters.i_uiAxisSelected, CST_LastOutletModuleAxis);
			IF 	stOutletModule.iq_stParameters.i_uiAxisSelected >= CST_FirstOutletModuleAxis	AND
				stOutletModule.iq_stParameters.i_uiAxisSelected <= CST_LastOutletModuleAxis		AND
				stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xAxisReal THEN
				IF stOutletModule.iq_stCmd.i_xOnePitchShift THEN
					stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xOnePitchShift := TRUE;
					uiAutoStep	:= 150;
				ELSIF stOutletModule.iq_stCmd.i_xPhaseShift AND stOutletModule.iq_stParameters.i_rPhaseShiftDistance <> 0 THEN
					stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stParam.i_rPhaseShiftDistance 	:= stOutletModule.iq_stParameters.i_rPhaseShiftDistance;
					stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xPhaseShift			:= TRUE;
					uiAutoStep	:= 180;
				END_IF
			END_IF
		ELSIF stOutletModule.iq_stStatus.q_xSynchroWithOffset AND stOutletModule.iq_stCmd.i_xPhaseCompensation THEN
			uiAutoStep	:= 300;
		END_IF

	150:(* Phase Shift Steps *)
		IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xPhaseShiftDone THEN
			stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xOnePitchShift := FALSE;
			uiAutoStep	:= 160;
		END_IF
		
	160:
		IF NOT stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xPhaseShiftDone THEN
			uiAutoStep	:= 130;
		END_IF

	180:
		IF stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stStatus.q_stMainAxisStatus.q_xPhaseShiftDone AND NOT stOutletModule.iq_stCmd.i_xPhaseShift THEN
			stOutletModule.iq_astSubModuleAxis[uiOldAxisSelected].iq_stCmd.i_xPhaseShift := FALSE;
			uiAutoStep	:= 160;
		END_IF
		
	300:(* Phase Offset Compensations *)
		FOR uiAxisIndex	:= CST_FirstOutletModuleAxis TO CST_LastOutletModuleAxis BY 1 DO
			IF stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xSynchroWithOffset THEN
				stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear 				:= FALSE;
				stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation	:= TRUE;
			END_IF
		END_FOR
		uiAutoStep	:= 310;
	
	310:
		IF NOT stOutletModule.iq_stStatus.q_xSynchroWithOffset THEN
			FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
				IF NOT stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xVelocityControl THEN
					stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xAxisReal;
				ELSE
					stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := NOT stOutletModule.iq_stCmd.i_xVelocityAxisStop;
				END_IF
				stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation	:= FALSE;
			END_FOR
			uiAutoStep	:= 120;
		END_IF
END_CASE

IF uiAutoStep > 120 AND EDGE(stOutletModule.iq_stCmd.i_xVelocityAxisStop) THEN
	FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
		IF stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xVelocityControl THEN
			stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear := NOT stOutletModule.iq_stCmd.i_xVelocityAxisStop;
		END_IF
	END_FOR
END_IF
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION
(* @LANGUAGE := 'st' *)
uiAutoStep	:= 0;
END_ACTION
EXIT_ACTION
(* @LANGUAGE := 'st' *)
stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xHome	:= FALSE;
stOutletModule.iq_stStatus.q_xMasterRephased := FALSE;
END_ACTION
TRANSITION FROM Auto TO AutoExit:=
NOT xAutoMode
END_TRANSITION
(* @SFCNOJUMP := 'AutoExit' *)
STEP AutoExit:
(* @LANGUAGE := 'st' *)
IF stOutletModule.iq_stStatus.q_xModuleStopped THEN
	FOR uiAxisIndex	:= uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
		stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xGear 				:= FALSE;
		stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xPhaseCompensation	:= FALSE;
	END_FOR
	
	IF NOT stOutletModule.iq_stStatus.q_xRealAxesSynchronized THEN
		stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xGear 				:= FALSE;
		stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stCmd.i_xPhaseCompensation	:= FALSE;
		xExitStep	:= NOT stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xSynchronized;
	END_IF
END_IF
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM AutoExit TO ModeSelection:=
xExitStep
END_TRANSITION
(* @SFCISJUMP := 'ModeSelection' *)
STEP SubModuleCalls:
(* @LANGUAGE := 'st' *)
(****** TOKEN RING ALGORITHM ******)
uiTokenIndex := uiTokenIndex + 1;
IF auiAxisTokenList[uiTokenIndex] = 0 THEN
	uiTokenIndex := 0;
END_IF
uiAxisToken := auiAxisTokenList[uiTokenIndex];

(* FUBs CALLS *)
fbOutletMaster.i_xToken	:= TRUE;
fbOutletMaster;

fbMain.i_xToken			:= (uiAxisToken = CST_MainAxis OR NOT CST_AxesMultiplexingOn);	//V4.A.A.1.6.10
fbMain;

FOR uiAxisIndex := CST_FirstOutletModuleAxis TO CST_LastOutletModuleAxis DO
	IF axAxisPresent[uiAxisIndex] THEN
		CASE uiAxisIndex OF
			CST_Inlet01:
				fbInlet01.i_xToken	:= uiAxisToken = uiAxisIndex	OR NOT CST_AxesMultiplexingOn	OR stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xCamConnected;	//V4.A.A.1.6.10
				fbInlet01;
			
			CST_Inlet02:
				fbInlet02.i_xToken	:= uiAxisToken = uiAxisIndex	OR NOT CST_AxesMultiplexingOn	OR stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xCamConnected;	//V4.A.A.1.6.10
				fbInlet02;
			
			CST_Inlet03:
				fbInlet03.i_xToken	:= uiAxisToken = uiAxisIndex 	OR NOT CST_AxesMultiplexingOn	OR stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xCamConnected;	//V4.A.A.1.6.10
				fbInlet03;
			
			CST_Inlet04:
				fbInlet04.i_xToken	:= uiAxisToken = uiAxisIndex	OR NOT CST_AxesMultiplexingOn	OR stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xCamConnected;	//V4.A.A.1.6.10
				fbInlet04;

			CST_Outlet01:
				fbOutlet01.i_xToken	:= uiAxisToken = uiAxisIndex	OR NOT CST_AxesMultiplexingOn	OR stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xCamConnected;	//V4.A.A.1.6.10
				fbOutlet01;
			
			CST_Outlet02:
				fbOutlet02.i_xToken	:= uiAxisToken = uiAxisIndex	OR NOT CST_AxesMultiplexingOn	OR stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xCamConnected;	//V4.A.A.1.6.10
				fbOutlet02;
			
			CST_Outlet03:
				fbOutlet03.i_xToken	:= uiAxisToken = uiAxisIndex	OR NOT CST_AxesMultiplexingOn	OR stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xCamConnected;	//V4.A.A.1.6.10
				fbOutlet03;
			
			CST_Outlet04:
				fbOutlet04.i_xToken	:= uiAxisToken = uiAxisIndex	OR NOT CST_AxesMultiplexingOn	OR stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stCmd.i_xCamConnected;	//V4.A.A.1.6.10
				fbOutlet04;
		END_CASE
	END_IF
END_FOR
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP SetException:
(* @LANGUAGE := 'st' *)
(* Set Exception Action *)
fbMpAlarmXCore(MpLink := ADR(gOutletAlarmXCoreLink), Enable := TRUE);
stOutletModule.iq_stStatus.q_xAlarmXCoreEnabled	:= fbMpAlarmXCore.Active;

(* Axis error *)
fbMasterError(i_xConditions := stOutletModule.iq_astSubModuleAxis[CST_ModuleMasterAxis].iq_stStatus.q_stMainAxisStatus.q_xError);

fbMainAxisError(i_xConditions		:= stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stStatus.q_stMainAxisStatus.q_xError);
fbMainAxisLagError(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_MainAxis].iq_stStatus.q_stMainAxisStatus.q_xLagError);

IF axAxisPresent[CST_Inlet01] THEN
	fbInlet01Error(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stStatus.q_stMainAxisStatus.q_xError);
	fbInlet01LagError(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Inlet01].iq_stStatus.q_stMainAxisStatus.q_xLagError);
END_IF

IF axAxisPresent[CST_Inlet02] THEN
	fbInlet02Error(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stStatus.q_stMainAxisStatus.q_xError);
	fbInlet02LagError(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Inlet02].iq_stStatus.q_stMainAxisStatus.q_xLagError);
END_IF

IF axAxisPresent[CST_Inlet03] THEN
	fbInlet03Error(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stStatus.q_stMainAxisStatus.q_xError);
	fbInlet03LagError(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Inlet03].iq_stStatus.q_stMainAxisStatus.q_xLagError);
END_IF

IF axAxisPresent[CST_Inlet04] THEN
	fbInlet04Error(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stStatus.q_stMainAxisStatus.q_xError);
	fbInlet04LagError(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Inlet04].iq_stStatus.q_stMainAxisStatus.q_xLagError);
END_IF

IF axAxisPresent[CST_Outlet01] THEN
	fbOutlet01Error(i_xConditions		:= stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stStatus.q_stMainAxisStatus.q_xError);
	fbOutlet01LagError(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Outlet01].iq_stStatus.q_stMainAxisStatus.q_xLagError);
END_IF
	
IF axAxisPresent[CST_Outlet02] THEN
	fbOutlet02Error(i_xConditions		:= stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stStatus.q_stMainAxisStatus.q_xError);
	fbOutlet02LagError(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Outlet02].iq_stStatus.q_stMainAxisStatus.q_xLagError);
END_IF
	
IF axAxisPresent[CST_Outlet03] THEN
	fbOutlet03Error(i_xConditions		:= stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stStatus.q_stMainAxisStatus.q_xError);
	fbOutlet03LagError(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Outlet03].iq_stStatus.q_stMainAxisStatus.q_xLagError);
END_IF
	
IF axAxisPresent[CST_Outlet04] THEN
	fbOutlet04Error(i_xConditions		:= stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stStatus.q_stMainAxisStatus.q_xError);
	fbOutlet04LagError(i_xConditions	:= stOutletModule.iq_astSubModuleAxis[CST_Outlet04].iq_stStatus.q_stMainAxisStatus.q_xLagError);
END_IF

fbEmergencyStopAlarm(i_xConditions	:= NOT stOutletModule.iq_stCmd.i_xEnable);
fbQuickStopFromPlc(i_xConditions	:= NOT stOutletModule.iq_stCmd.i_xExternalQuickStop);
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP Output:
(* @LANGUAGE := 'st' *)
(* Modalities Bits *)
stOutletModule.iq_stStatus.q_xNoOpActive			:= xNoOpActive;
stOutletModule.iq_stStatus.q_xAutoActive 			:= xAutoActive;
stOutletModule.iq_stStatus.q_xPositioningActive 	:= xPositioningActive;
stOutletModule.iq_stStatus.q_xSelHomingActive 		:= xSelHomingActive;
stOutletModule.iq_stStatus.q_xBrakeReleaseActive 	:= xBrakeReleaseActive;
stOutletModule.iq_stStatus.q_xSlowMotionActive 		:= xSlowMotionActive;
stOutletModule.iq_stStatus.q_xJogMultiActive 		:= xJogMultiActive;
stOutletModule.iq_stStatus.q_xAutoMultiActive 		:= xAutoMultiActive;
stOutletModule.iq_stStatus.q_xStepByStepActive 		:= xStepByStepActive;
stOutletModule.iq_stStatus.q_xVelocityActive 		:= xVelocityActive;
stOutletModule.iq_stStatus.q_xThirdPartySetupActive	:= xThirdPartySetupActive;
stOutletModule.iq_stStatus.q_xInductionSetupActive	:= xInductionSetupActive;

stOutletModule.iq_stStatus.q_xModuleStartFbk	:= (xAutoMultiActive	AND stOutletModule.iq_stCmd.i_xStart)	OR
													(xJogMultiActive	AND stOutletModule.iq_stCmd.i_xJogPB)	OR
													(xSlowMotionActive	AND stOutletModule.iq_stCmd.i_xJogPB);

CASE uiSlowAxisIndex OF
	CST_ModuleMasterAxis:
		stOutletModule.iq_stStatus.q_xModulePowered				:= xModulePowered;
		stOutletModule.iq_stStatus.q_xRealAxesReadyForACommand	:= xRealAxesReadyForACommand;
		stOutletModule.iq_stStatus.q_xSynchroWithOffset			:= xSynchroWithOffset;
		stOutletModule.iq_stStatus.q_xModuleStopped				:= xModuleStopped;
		stOutletModule.iq_stStatus.q_xRealAxesSynchronized		:= xRealAxesSynchronized;
		stOutletModule.iq_stStatus.q_xPhaseShiftDone			:= xPhaseShiftDone;
		stOutletModule.iq_stStatus.q_xSelHomingDone				:= xSelHomingDone;
		stOutletModule.iq_stStatus.q_xModuleHomed				:= xModuleHomed;
		stOutletModule.iq_stStatus.q_xInitDone					:= xModuleInitialized;
		
		// Module Velocity
		stOutletModule.iq_stStatus.q_rVelocity					:= rModuleVelocity;
		rModuleVelocity											:= ABS(stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_rVelocity);
		usiMasterStatus											:= usiMasterTempStatus;
		usiMasterTempStatus										:= usiMasterRequest;

	CST_FirstOutletModuleAxis..CST_LastOutletModuleAxis:
		IF NOT stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xPowerSupply	AND
			stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xAxisReal			THEN

			IF NOT stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xVelocityControl THEN
				rModuleVelocity	:= MAX(rModuleVelocity, ABS(stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_rVelocity));
			END_IF

			// Master management	
			IF	usiMasterRequest = LOCAL_MASTER THEN
				IF stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_udiMasterAxisLink <> ADR(gOutletModuleMasterLink) AND usiMasterTempStatus <> UNKNOWN THEN
					usiMasterTempStatus := UNKNOWN;
				END_IF
			ELSIF usiMasterRequest = GLOBAL_MASTER THEN				
				IF stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_udiMasterAxisLink <> ADR(gMasterLink) AND usiMasterTempStatus <> UNKNOWN THEN
					usiMasterTempStatus := UNKNOWN;
				END_IF
			ELSE
				usiMasterStatus	:= UNKNOWN;
			END_IF

			// Module Initialized Memory
			xModuleInitialized	:= xModuleInitialized AND
									stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xInitDone;

			// Axis Homed cumulative memory
			xModuleHomed		:= xModuleHomed AND
									stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xIsHomed;
					
			// Axis stopped cumulative memory		
			xModuleStopped		:= xModuleStopped AND
									(stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xStopped OR NOT
									stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xPoweredOn);
			
			// Ready for a command cumulative memory
			xRealAxesReadyForACommand	:= xRealAxesReadyForACommand AND stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xReadyForACommand;
			
			IF NOT stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xAxisDisabled THEN
				// Axis syncrhonized cumulative memory
				xRealAxesSynchronized	:= xRealAxesSynchronized	AND stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xSynchronized;
				// There is at least One Axis with a phase offset pending
				xSynchroWithOffset		:= xSynchroWithOffset		OR stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xSynchroWithOffset;
				// Phase shift done
				xPhaseShiftDone			:= xPhaseShiftDone 	OR (stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xPhaseShiftDone AND stOutletModule.iq_astSubModuleAxis[uiSlowAxisIndex].iq_stCmd.i_xPhaseShift);
			END_IF
		END_IF
	ELSE
		xRealAxesReadyForACommand	:= TRUE;
		xSynchroWithOffset			:= FALSE;
		xModuleStopped				:= TRUE;
		xRealAxesSynchronized		:= TRUE;
		xPhaseShiftDone				:= FALSE;
		xSelHomingDone				:= FALSE;
		xModuleHomed				:= TRUE;
		xModuleInitialized			:= TRUE;
END_CASE

stOutletModule.iq_stStatus.q_xModulePowered		:= FALSE;
stOutletModule.iq_stStatus.q_xReactionActive	:= xReactionActive;

FOR uiAxisIndex := uiFirstOutletModuleAxis TO uiLastOutletModuleAxis BY 1 DO
	// Axis powered cumulative memory
	stOutletModule.iq_stStatus.q_xModulePowered	:= stOutletModule.iq_stStatus.q_xModulePowered		OR
													(stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xPoweredOn 		AND
													NOT stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xPowerSupply 	AND
													stOutletModule.iq_astSubModuleAxis[uiAxisIndex].iq_stStatus.q_stMainAxisStatus.q_xAxisReal);
END_FOR

stOutletModule.iq_stStatus.q_xModuleSynchronized		:= stOutletModule.iq_stStatus.q_xRealAxesSynchronized;
(*DA IMPLEMENTARE FB COME C'E' NEL MODULO FILLER*)
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM (Input,SubModuleCalls,SetException,Output) TO Disabled:=
FALSE
END_TRANSITION
(* @SFCNOJUMP := 'Disabled' *)
STEP Disabled:
(* @LANGUAGE := 'st' *)
stOutletModule.iq_stStatus.q_xAlarmXCoreEnabled	:= TRUE;
ST_tmp_suspend(0);	// Suspend the outlet module task
END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Disabled TO Init:=
FALSE
END_TRANSITION
(* @SFCISJUMP := 'Init' *)
END_PROGRAM
